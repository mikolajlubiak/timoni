package fp

// This file is automatically generated, manual editing is not recommended.

import (
	"encoding/json"
	"fmt"
	"time"

	"fyne.io/fyne/v2/data/binding"
	"github.com/lukx33/lwhelper"
	"github.com/lukx33/lwhelper/out"
)

var tmpDomain = lwhelper.ID()

type Domain interface {
	NotValid() bool
	InfoAddTrace(result out.ResultT, msg string, skipFrames int)
	InfoAddCause(parent out.Info) out.Info
	InfoAddVar(name string, value any) out.Info
	InfoResult() out.ResultT
	InfoTraces() []out.TraceS
	InfoLastTrace() out.TraceS
	InfoJSON() []byte
	InfoPrint()

	ID() string
	Created() int64
	Updated() int64

	Cert() Cert
	SetCert(value Cert) out.Info
	CertProvider() CertProvider
	SetCertProvider(value CertProvider) out.Info
	CertRenewBeforeDays() int64
	SetCertRenewBeforeDays(value int64) out.Info
	CertRenewError() string
	SetCertRenewError(value string) out.Info
	DNSProvider() DNSProvider
	SetDNSProvider(value DNSProvider) out.Info
	Enabled() bool
	SetEnabled(value bool) out.Info
	HTTPS() bool
	SetHTTPS(value bool) out.Info
	IP() string
	SetIP(value string) out.Info
	Name() string
	SetName(value string) out.Info
	Organization() Organization
	SetOrganization(value Organization) out.Info
	Port() int64
	SetPort(value int64) out.Info
	TLD() string
	SetTLD(value string) out.Info
	Delete() out.Info
	URL(path string) string
}
type domainS struct {
	out.DontUseMeInfoS

	IDC      string
	CreatedC int64
	UpdatedC int64

	CertC                string
	CertProviderC        string
	CertRenewBeforeDaysC int64
	CertRenewErrorC      string
	DNSProviderC         string
	EnabledC             bool
	HTTPSC               bool
	IPC                  string
	NameC                string
	OrganizationC        string
	PortC                int64
	TLDC                 string
}

func (o *domainS) dataMapEN() map[string]string {
	return map[string]string{
		"ID":                  o.IDC,
		"Created":             fmt.Sprint(o.CreatedC),
		"Updated":             fmt.Sprint(o.UpdatedC),
		"Cert":                o.CertC,
		"CertProvider":        o.CertProviderC,
		"CertRenewBeforeDays": fmt.Sprint(o.CertRenewBeforeDaysC),
		"CertRenewError":      o.CertRenewErrorC,
		"DNSProvider":         o.DNSProviderC,
		"Enabled":             fmt.Sprint(o.EnabledC),
		"HTTPS":               fmt.Sprint(o.HTTPSC),
		"IP":                  o.IPC,
		"Name":                o.NameC,
		"Organization":        o.OrganizationC,
		"Port":                fmt.Sprint(o.PortC),
		"TLD":                 o.TLDC,
	}
}

// ---

func (o *domainS) AddListener(l binding.DataListener) {
	fmt.Println("Domain AddListener")
}

func (o *domainS) RemoveListener(l binding.DataListener) {
	fmt.Println("Domain RemoveListener")
}

// ---

func (o *domainS) InfoJSON() []byte {
	buf, _ := json.MarshalIndent(o, "", "  ")
	return buf
}

func (o *domainS) InfoPrint() {
	fmt.Println(string(o.InfoJSON()))
}

// ---
// ID

func (o *domainS) ID() string {
	if o == nil {
		return ""
	}
	return o.IDC
}

// ---
// Created

func (o *domainS) Created() int64 {
	if o == nil {
		return 0
	}
	return o.CreatedC
}

// ---
// Updated

func (o *domainS) Updated() int64 {
	if o == nil {
		return 0
	}
	return o.UpdatedC
}

// ---
// Cert

func (o *domainS) Cert() Cert {
	return CertGetByID(o.CertC)
}

func (o *domainS) SetCert(value Cert) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	response := new(out.DontUseMeInfoS)
	client.call(
		"DomainSetCert",
		req_setRelationS{
			ID:     o.IDC,
			NewKey: value.ID(),
		},
		response,
	)
	if response.NotValid() {
		return response
	}

	o.CertC = value.ID()
	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// CertProvider

func (o *domainS) CertProvider() CertProvider {
	return CertProviderGetByID(o.CertProviderC)
}

func (o *domainS) SetCertProvider(value CertProvider) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	response := new(out.DontUseMeInfoS)
	client.call(
		"DomainSetCertProvider",
		req_setRelationS{
			ID:     o.IDC,
			NewKey: value.ID(),
		},
		response,
	)
	if response.NotValid() {
		return response
	}

	o.CertProviderC = value.ID()
	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// CertRenewBeforeDays

func (o *domainS) CertRenewBeforeDays() int64 {
	return o.CertRenewBeforeDaysC
}

func (o *domainS) SetCertRenewBeforeDays(value int64) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	response := new(out.DontUseMeInfoS)
	client.call(
		"DomainSetCertRenewBeforeDays",
		req_setInt64S{
			ID:       o.IDC,
			NewValue: value,
		},
		response,
	)
	if response.NotValid() {
		return response
	}

	o.CertRenewBeforeDaysC = value
	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// CertRenewError

func (o *domainS) CertRenewError() string {
	return o.CertRenewErrorC
}

func (o *domainS) SetCertRenewError(value string) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	response := new(out.DontUseMeInfoS)
	client.call(
		"DomainSetCertRenewError",
		req_setStringS{
			ID:       o.IDC,
			NewValue: value,
		},
		response,
	)
	if response.NotValid() {
		return response
	}

	o.CertRenewErrorC = value
	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// DNSProvider

func (o *domainS) DNSProvider() DNSProvider {
	return DNSProviderGetByID(o.DNSProviderC)
}

func (o *domainS) SetDNSProvider(value DNSProvider) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	response := new(out.DontUseMeInfoS)
	client.call(
		"DomainSetDNSProvider",
		req_setRelationS{
			ID:     o.IDC,
			NewKey: value.ID(),
		},
		response,
	)
	if response.NotValid() {
		return response
	}

	o.DNSProviderC = value.ID()
	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// Enabled

func (o *domainS) Enabled() bool {
	return o.EnabledC
}

func (o *domainS) SetEnabled(value bool) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	response := new(out.DontUseMeInfoS)
	client.call(
		"DomainSetEnabled",
		req_setBoolS{
			ID:       o.IDC,
			NewValue: value,
		},
		response,
	)
	if response.NotValid() {
		return response
	}

	o.EnabledC = value
	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// HTTPS

func (o *domainS) HTTPS() bool {
	return o.HTTPSC
}

func (o *domainS) SetHTTPS(value bool) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	response := new(out.DontUseMeInfoS)
	client.call(
		"DomainSetHTTPS",
		req_setBoolS{
			ID:       o.IDC,
			NewValue: value,
		},
		response,
	)
	if response.NotValid() {
		return response
	}

	o.HTTPSC = value
	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// IP

func (o *domainS) IP() string {
	return o.IPC
}

func (o *domainS) SetIP(value string) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	response := new(out.DontUseMeInfoS)
	client.call(
		"DomainSetIP",
		req_setStringS{
			ID:       o.IDC,
			NewValue: value,
		},
		response,
	)
	if response.NotValid() {
		return response
	}

	o.IPC = value
	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// Name

func (o *domainS) Name() string {
	return o.NameC
}

func (o *domainS) SetName(value string) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	response := new(out.DontUseMeInfoS)
	client.call(
		"DomainSetName",
		req_setStringS{
			ID:       o.IDC,
			NewValue: value,
		},
		response,
	)
	if response.NotValid() {
		return response
	}

	o.NameC = value
	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// Organization

func (o *domainS) Organization() Organization {
	return OrganizationGetByID(o.OrganizationC)
}

func (o *domainS) SetOrganization(value Organization) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	response := new(out.DontUseMeInfoS)
	client.call(
		"DomainSetOrganization",
		req_setRelationS{
			ID:     o.IDC,
			NewKey: value.ID(),
		},
		response,
	)
	if response.NotValid() {
		return response
	}

	o.OrganizationC = value.ID()
	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// Port

func (o *domainS) Port() int64 {
	return o.PortC
}

func (o *domainS) SetPort(value int64) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	response := new(out.DontUseMeInfoS)
	client.call(
		"DomainSetPort",
		req_setInt64S{
			ID:       o.IDC,
			NewValue: value,
		},
		response,
	)
	if response.NotValid() {
		return response
	}

	o.PortC = value
	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// TLD

func (o *domainS) TLD() string {
	return o.TLDC
}

func (o *domainS) SetTLD(value string) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	response := new(out.DontUseMeInfoS)
	client.call(
		"DomainSetTLD",
		req_setStringS{
			ID:       o.IDC,
			NewValue: value,
		},
		response,
	)
	if response.NotValid() {
		return response
	}

	o.TLDC = value
	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---

func DomainGetByID(ID string) Domain {

	response := &domainS{}
	client.call(
		"DomainGetByID",
		req_oneS{
			ID: ID,
		},
		response,
	)

	return response
}

func (o *domainS) URL(path string) string {

	scheme := "https"
	if o.CertC == "" {
		scheme = "http"
	}

	return fmt.Sprintf("%s://%s:%d%s", scheme, o.NameC, o.PortC, path)
}

// ---

func (o *domainS) Delete() out.Info {

	response := new(out.DontUseMeInfoS)
	client.call(
		"DomainDelete",
		req_oneS{
			ID: o.ID(),
		},
		response,
	)

	return response
}

// ---

type req_DomainCreateS struct {
	Cert         string
	CertProvider string
	DNSProvider  string
	IP           string
	Name         string
	Organization string
	TLD          string
}

func DomainCreate(
	Cert Cert,
	CertProvider CertProvider,
	DNSProvider DNSProvider,
	IP string,
	Name string,
	Organization Organization,
	TLD string,

) Domain {

	response := &domainS{}
	client.call(
		"DomainCreate",
		req_DomainCreateS{
			Cert:         Cert.ID(),
			CertProvider: CertProvider.ID(),
			DNSProvider:  DNSProvider.ID(),
			IP:           IP,
			Name:         Name,
			Organization: Organization.ID(),
			TLD:          TLD,
		},
		response,
	)
	return response
}

// ----------------------------------------------------- table list:

type domainList interface {
	NotValid() bool
	InfoAddTrace(result out.ResultT, msg string, skipFrames int)
	InfoAddCause(parent out.Info) out.Info
	InfoAddVar(name string, value any) out.Info
	InfoResult() out.ResultT
	InfoTraces() []out.TraceS
	InfoLastTrace() out.TraceS
	InfoJSON() []byte
	InfoPrint()

	Length() int
	First() Domain
	GetByID(id string) Domain
	Iter() []Domain
	Refresh() out.Info
	SetWhere(where string) out.Info
	SetOrder(order string) out.Info
	SetOffset(offset int) out.Info
	SetLimit(limit int) out.Info

	AddListener(dl binding.DataListener)
	RemoveListener(dl binding.DataListener)
	GetItem(index int) (binding.DataItem, error)
}

type domainListS struct {
	out.DontUseMeInfoS

	query   req_listQueryS
	IDs     []string
	IDtoIdx map[string]int
	M       map[string]*domainS

	dataListener map[binding.DataListener]bool
}

func (o *domainListS) InfoJSON() []byte {
	buf, _ := json.MarshalIndent(o, "", "  ")
	return buf
}

func (o *domainListS) InfoPrint() {
	fmt.Println(string(o.InfoJSON()))
}

func (o *domainListS) AddListener(dl binding.DataListener) {
	// fmt.Println("DomainList AddListener")
	if o.dataListener == nil {
		o.dataListener = map[binding.DataListener]bool{}
	}
	o.dataListener[dl] = true
}

func (o *domainListS) RemoveListener(dl binding.DataListener) {
	// fmt.Println("DomainList RemoveListener")
	delete(o.dataListener, dl)
}

func (o *domainListS) GetItem(index int) (binding.DataItem, error) {
	// fmt.Println("DomainList GetItem")
	return o.M[o.IDs[index]], nil
}

func (o *domainListS) Length() int {
	// fmt.Println("DomainList Length")
	return len(o.IDs)
}

//---

func DomainList(where, order string, offset, limit int) domainList {

	response := &domainListS{
		query: req_listQueryS{
			Where:  where,
			Order:  order,
			Offset: offset,
			Limit:  limit,
		},
	}

	if where == "nil" {
		return response
	}

	response.Refresh()
	return response
}

func (o *domainListS) SetWhere(where string) out.Info {
	o.query = req_listQueryS{
		Where: where,
	}
	return o.Refresh()
}

func (o *domainListS) SetOrder(order string) out.Info {
	o.query = req_listQueryS{
		Order: order,
	}
	return o.Refresh()
}

func (o *domainListS) SetOffset(offset int) out.Info {
	o.query = req_listQueryS{
		Offset: offset,
	}
	return o.Refresh()
}

func (o *domainListS) SetLimit(limit int) out.Info {
	o.query = req_listQueryS{
		Limit: limit,
	}
	return o.Refresh()
}

func (o *domainListS) First() Domain {
	for _, obj := range o.M {
		return out.CatchError(obj, nil)
	}

	res := &domainS{}
	res.InfoAddTrace(out.NotFound, "", 0)
	return res
}

func (o *domainListS) Iter() []Domain {

	if o.NotValid() {
		return nil
	}

	res := []Domain{}
	for _, id := range o.IDs {
		res = append(res, out.CatchError(o.M[id], nil))
	}
	return res
}

func (o *domainListS) Refresh() out.Info {

	if o.query.Where == "nil" {
		return o
	}

	response := &domainListS{
		query:        o.query,
		IDs:          []string{},
		IDtoIdx:      map[string]int{},
		M:            map[string]*domainS{},
		dataListener: o.dataListener,
	}

	client.call(
		"DomainList",
		o.query,
		response,
	)
	*o = *response

	for dl := range o.dataListener {
		// fmt.Println(">>>>>>>>>>>>>>>>>> dataListener", dl)
		dl.DataChanged()
	}
	return o
}

func (o *domainListS) GetByID(id string) Domain {
	return out.CatchError(o.M[id], nil)
}

//---

func (o *domainListS) GetByName(name string) Domain {

	for _, obj := range o.M {
		if obj.NameC == name {
			return out.CatchError(obj, nil)
		}
	}

	res := &domainS{}
	res.InfoAddTrace(out.NotFound, "", 0)
	return res
}
