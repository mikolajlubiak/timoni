package fp

// This file is automatically generated, manual editing is not recommended.

import (
	"encoding/json"
	"fmt"
	"time"

	"fyne.io/fyne/v2/data/binding"
	"github.com/lukx33/lwhelper"
	"github.com/lukx33/lwhelper/out"
)

var tmpCert = lwhelper.ID()

type Cert interface {
	NotValid() bool
	InfoAddTrace(result out.ResultT, msg string, skipFrames int)
	InfoAddCause(parent out.Info) out.Info
	InfoAddVar(name string, value any) out.Info
	InfoResult() out.ResultT
	InfoTraces() []out.TraceS
	InfoLastTrace() out.TraceS
	InfoJSON() []byte
	InfoPrint()

	ID() string
	Created() int64
	Updated() int64

	DomainName() string
	SetDomainName(value string) out.Info
	ExpirationTime() int64
	SetExpirationTime(value int64) out.Info
	Key() string
	SetKey(value string) out.Info
	Organization() Organization
	SetOrganization(value Organization) out.Info
	Pem() string
	SetPem(value string) out.Info
	Delete() out.Info
}
type certS struct {
	out.DontUseMeInfoS

	IDC      string
	CreatedC int64
	UpdatedC int64

	DomainNameC     string
	ExpirationTimeC int64
	KeyC            string
	OrganizationC   string
	PemC            string
}

func (o *certS) dataMapEN() map[string]string {
	return map[string]string{
		"ID":             o.IDC,
		"Created":        fmt.Sprint(o.CreatedC),
		"Updated":        fmt.Sprint(o.UpdatedC),
		"DomainName":     o.DomainNameC,
		"ExpirationTime": fmt.Sprint(o.ExpirationTimeC),
		"Key":            o.KeyC,
		"Organization":   o.OrganizationC,
		"Pem":            o.PemC,
	}
}

// ---

func (o *certS) AddListener(l binding.DataListener) {
	fmt.Println("Cert AddListener")
}

func (o *certS) RemoveListener(l binding.DataListener) {
	fmt.Println("Cert RemoveListener")
}

// ---

func (o *certS) InfoJSON() []byte {
	buf, _ := json.MarshalIndent(o, "", "  ")
	return buf
}

func (o *certS) InfoPrint() {
	fmt.Println(string(o.InfoJSON()))
}

// ---
// ID

func (o *certS) ID() string {
	if o == nil {
		return ""
	}
	return o.IDC
}

// ---
// Created

func (o *certS) Created() int64 {
	if o == nil {
		return 0
	}
	return o.CreatedC
}

// ---
// Updated

func (o *certS) Updated() int64 {
	if o == nil {
		return 0
	}
	return o.UpdatedC
}

// ---
// DomainName

func (o *certS) DomainName() string {
	return o.DomainNameC
}

func (o *certS) SetDomainName(value string) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	response := new(out.DontUseMeInfoS)
	client.call(
		"CertSetDomainName",
		req_setStringS{
			ID:       o.IDC,
			NewValue: value,
		},
		response,
	)
	if response.NotValid() {
		return response
	}

	o.DomainNameC = value
	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// ExpirationTime

func (o *certS) ExpirationTime() int64 {
	return o.ExpirationTimeC
}

func (o *certS) SetExpirationTime(value int64) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	response := new(out.DontUseMeInfoS)
	client.call(
		"CertSetExpirationTime",
		req_setInt64S{
			ID:       o.IDC,
			NewValue: value,
		},
		response,
	)
	if response.NotValid() {
		return response
	}

	o.ExpirationTimeC = value
	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// Key

func (o *certS) Key() string {
	return o.KeyC
}

func (o *certS) SetKey(value string) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	response := new(out.DontUseMeInfoS)
	client.call(
		"CertSetKey",
		req_setStringS{
			ID:       o.IDC,
			NewValue: value,
		},
		response,
	)
	if response.NotValid() {
		return response
	}

	o.KeyC = value
	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// Organization

func (o *certS) Organization() Organization {
	return OrganizationGetByID(o.OrganizationC)
}

func (o *certS) SetOrganization(value Organization) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	response := new(out.DontUseMeInfoS)
	client.call(
		"CertSetOrganization",
		req_setRelationS{
			ID:     o.IDC,
			NewKey: value.ID(),
		},
		response,
	)
	if response.NotValid() {
		return response
	}

	o.OrganizationC = value.ID()
	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// Pem

func (o *certS) Pem() string {
	return o.PemC
}

func (o *certS) SetPem(value string) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	response := new(out.DontUseMeInfoS)
	client.call(
		"CertSetPem",
		req_setStringS{
			ID:       o.IDC,
			NewValue: value,
		},
		response,
	)
	if response.NotValid() {
		return response
	}

	o.PemC = value
	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---

func CertGetByID(ID string) Cert {

	response := &certS{}
	client.call(
		"CertGetByID",
		req_oneS{
			ID: ID,
		},
		response,
	)

	return response
}

// ---

func (o *certS) Delete() out.Info {

	response := new(out.DontUseMeInfoS)
	client.call(
		"CertDelete",
		req_oneS{
			ID: o.ID(),
		},
		response,
	)

	return response
}

// ---

type req_CertCreateS struct {
	DomainName     string
	ExpirationTime int64
	Key            string
	Organization   string
	Pem            string
}

func CertCreate(
	DomainName string,
	ExpirationTime int64,
	Key string,
	Organization Organization,
	Pem string,

) Cert {

	response := &certS{}
	client.call(
		"CertCreate",
		req_CertCreateS{
			DomainName:     DomainName,
			ExpirationTime: ExpirationTime,
			Key:            Key,
			Organization:   Organization.ID(),
			Pem:            Pem,
		},
		response,
	)
	return response
}

// ----------------------------------------------------- table list:

type certList interface {
	NotValid() bool
	InfoAddTrace(result out.ResultT, msg string, skipFrames int)
	InfoAddCause(parent out.Info) out.Info
	InfoAddVar(name string, value any) out.Info
	InfoResult() out.ResultT
	InfoTraces() []out.TraceS
	InfoLastTrace() out.TraceS
	InfoJSON() []byte
	InfoPrint()

	Length() int
	First() Cert
	GetByID(id string) Cert
	Iter() []Cert
	Refresh() out.Info
	SetWhere(where string) out.Info
	SetOrder(order string) out.Info
	SetOffset(offset int) out.Info
	SetLimit(limit int) out.Info

	AddListener(dl binding.DataListener)
	RemoveListener(dl binding.DataListener)
	GetItem(index int) (binding.DataItem, error)
}

type certListS struct {
	out.DontUseMeInfoS

	query   req_listQueryS
	IDs     []string
	IDtoIdx map[string]int
	M       map[string]*certS

	dataListener map[binding.DataListener]bool
}

func (o *certListS) InfoJSON() []byte {
	buf, _ := json.MarshalIndent(o, "", "  ")
	return buf
}

func (o *certListS) InfoPrint() {
	fmt.Println(string(o.InfoJSON()))
}

func (o *certListS) AddListener(dl binding.DataListener) {
	// fmt.Println("CertList AddListener")
	if o.dataListener == nil {
		o.dataListener = map[binding.DataListener]bool{}
	}
	o.dataListener[dl] = true
}

func (o *certListS) RemoveListener(dl binding.DataListener) {
	// fmt.Println("CertList RemoveListener")
	delete(o.dataListener, dl)
}

func (o *certListS) GetItem(index int) (binding.DataItem, error) {
	// fmt.Println("CertList GetItem")
	return o.M[o.IDs[index]], nil
}

func (o *certListS) Length() int {
	// fmt.Println("CertList Length")
	return len(o.IDs)
}

//---

func CertList(where, order string, offset, limit int) certList {

	response := &certListS{
		query: req_listQueryS{
			Where:  where,
			Order:  order,
			Offset: offset,
			Limit:  limit,
		},
	}

	if where == "nil" {
		return response
	}

	response.Refresh()
	return response
}

func (o *certListS) SetWhere(where string) out.Info {
	o.query = req_listQueryS{
		Where: where,
	}
	return o.Refresh()
}

func (o *certListS) SetOrder(order string) out.Info {
	o.query = req_listQueryS{
		Order: order,
	}
	return o.Refresh()
}

func (o *certListS) SetOffset(offset int) out.Info {
	o.query = req_listQueryS{
		Offset: offset,
	}
	return o.Refresh()
}

func (o *certListS) SetLimit(limit int) out.Info {
	o.query = req_listQueryS{
		Limit: limit,
	}
	return o.Refresh()
}

func (o *certListS) First() Cert {
	for _, obj := range o.M {
		return out.CatchError(obj, nil)
	}

	res := &certS{}
	res.InfoAddTrace(out.NotFound, "", 0)
	return res
}

func (o *certListS) Iter() []Cert {

	if o.NotValid() {
		return nil
	}

	res := []Cert{}
	for _, id := range o.IDs {
		res = append(res, out.CatchError(o.M[id], nil))
	}
	return res
}

func (o *certListS) Refresh() out.Info {

	if o.query.Where == "nil" {
		return o
	}

	response := &certListS{
		query:        o.query,
		IDs:          []string{},
		IDtoIdx:      map[string]int{},
		M:            map[string]*certS{},
		dataListener: o.dataListener,
	}

	client.call(
		"CertList",
		o.query,
		response,
	)
	*o = *response

	for dl := range o.dataListener {
		// fmt.Println(">>>>>>>>>>>>>>>>>> dataListener", dl)
		dl.DataChanged()
	}
	return o
}

func (o *certListS) GetByID(id string) Cert {
	return out.CatchError(o.M[id], nil)
}

//---
