package fp

// This file is automatically generated, manual editing is not recommended.

import (
	"encoding/json"
	"fmt"
	"time"

	"fyne.io/fyne/v2/data/binding"
	"github.com/lukx33/lwhelper"
	"github.com/lukx33/lwhelper/out"
)

var tmpUser = lwhelper.ID()

type User interface {
	NotValid() bool
	InfoAddTrace(result out.ResultT, msg string, skipFrames int)
	InfoAddCause(parent out.Info) out.Info
	InfoAddVar(name string, value any) out.Info
	InfoResult() out.ResultT
	InfoTraces() []out.TraceS
	InfoLastTrace() out.TraceS
	InfoJSON() []byte
	InfoPrint()

	ID() string
	Created() int64
	Updated() int64

	Email() string
	SetEmail(value string) out.Info
	FirstName() string
	SetFirstName(value string) out.Info
	LastName() string
	SetLastName(value string) out.Info
	Status() UserStatusT
	SetStatus(value UserStatusT) out.Info
	TotpSecret() string
	SetTotpSecret(value string) out.Info
	Delete() out.Info
}
type userS struct {
	out.DontUseMeInfoS

	IDC      string
	CreatedC int64
	UpdatedC int64

	EmailC      string
	FirstNameC  string
	LastNameC   string
	StatusC     UserStatusT
	TotpSecretC string
}

func (o *userS) dataMapEN() map[string]string {
	return map[string]string{
		"ID":         o.IDC,
		"Created":    fmt.Sprint(o.CreatedC),
		"Updated":    fmt.Sprint(o.UpdatedC),
		"Email":      o.EmailC,
		"FirstName":  o.FirstNameC,
		"LastName":   o.LastNameC,
		"Status":     o.StatusC.EN(),
		"TotpSecret": o.TotpSecretC,
	}
}

// ---

func (o *userS) AddListener(l binding.DataListener) {
	fmt.Println("User AddListener")
}

func (o *userS) RemoveListener(l binding.DataListener) {
	fmt.Println("User RemoveListener")
}

// ---

func (o *userS) InfoJSON() []byte {
	buf, _ := json.MarshalIndent(o, "", "  ")
	return buf
}

func (o *userS) InfoPrint() {
	fmt.Println(string(o.InfoJSON()))
}

// ---
// ID

func (o *userS) ID() string {
	if o == nil {
		return ""
	}
	return o.IDC
}

// ---
// Created

func (o *userS) Created() int64 {
	if o == nil {
		return 0
	}
	return o.CreatedC
}

// ---
// Updated

func (o *userS) Updated() int64 {
	if o == nil {
		return 0
	}
	return o.UpdatedC
}

// ---
// Email

func (o *userS) Email() string {
	return o.EmailC
}

func (o *userS) SetEmail(value string) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	response := new(out.DontUseMeInfoS)
	client.call(
		"UserSetEmail",
		req_setStringS{
			ID:       o.IDC,
			NewValue: value,
		},
		response,
	)
	if response.NotValid() {
		return response
	}

	o.EmailC = value
	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// FirstName

func (o *userS) FirstName() string {
	return o.FirstNameC
}

func (o *userS) SetFirstName(value string) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	response := new(out.DontUseMeInfoS)
	client.call(
		"UserSetFirstName",
		req_setStringS{
			ID:       o.IDC,
			NewValue: value,
		},
		response,
	)
	if response.NotValid() {
		return response
	}

	o.FirstNameC = value
	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// LastName

func (o *userS) LastName() string {
	return o.LastNameC
}

func (o *userS) SetLastName(value string) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	response := new(out.DontUseMeInfoS)
	client.call(
		"UserSetLastName",
		req_setStringS{
			ID:       o.IDC,
			NewValue: value,
		},
		response,
	)
	if response.NotValid() {
		return response
	}

	o.LastNameC = value
	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// Status

func (o *userS) Status() UserStatusT {
	return o.StatusC
}

func (o *userS) SetStatus(value UserStatusT) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	response := new(out.DontUseMeInfoS)
	client.call(
		"UserSetStatus",
		req_setUInt16S{
			ID:       o.IDC,
			NewValue: uint16(value),
		},
		response,
	)
	if response.NotValid() {
		return response
	}

	o.StatusC = value
	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// TotpSecret

func (o *userS) TotpSecret() string {
	return o.TotpSecretC
}

func (o *userS) SetTotpSecret(value string) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	response := new(out.DontUseMeInfoS)
	client.call(
		"UserSetTotpSecret",
		req_setStringS{
			ID:       o.IDC,
			NewValue: value,
		},
		response,
	)
	if response.NotValid() {
		return response
	}

	o.TotpSecretC = value
	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---

func UserGetByID(ID string) User {

	response := &userS{}
	client.call(
		"UserGetByID",
		req_oneS{
			ID: ID,
		},
		response,
	)

	return response
}

// ---

func UserGetByEmail(Email string) User {

	response := &userS{}
	client.call(
		"UserGetByEmail",
		req_oneS{
			ID: Email,
		},
		response,
	)

	return response
}

// ---

func (o *userS) Delete() out.Info {

	response := new(out.DontUseMeInfoS)
	client.call(
		"UserDelete",
		req_oneS{
			ID: o.ID(),
		},
		response,
	)

	return response
}

// ---

type req_UserCreateS struct {
	Email string
}

func UserCreate(
	Email string,

) User {

	response := &userS{}
	client.call(
		"UserCreate",
		req_UserCreateS{
			Email: Email,
		},
		response,
	)
	return response
}

// ----------------------------------------------------- table list:

type userList interface {
	NotValid() bool
	InfoAddTrace(result out.ResultT, msg string, skipFrames int)
	InfoAddCause(parent out.Info) out.Info
	InfoAddVar(name string, value any) out.Info
	InfoResult() out.ResultT
	InfoTraces() []out.TraceS
	InfoLastTrace() out.TraceS
	InfoJSON() []byte
	InfoPrint()

	Length() int
	First() User
	GetByID(id string) User
	Iter() []User
	Refresh() out.Info
	SetWhere(where string) out.Info
	SetOrder(order string) out.Info
	SetOffset(offset int) out.Info
	SetLimit(limit int) out.Info

	AddListener(dl binding.DataListener)
	RemoveListener(dl binding.DataListener)
	GetItem(index int) (binding.DataItem, error)
}

type userListS struct {
	out.DontUseMeInfoS

	query   req_listQueryS
	IDs     []string
	IDtoIdx map[string]int
	M       map[string]*userS

	dataListener map[binding.DataListener]bool
}

func (o *userListS) InfoJSON() []byte {
	buf, _ := json.MarshalIndent(o, "", "  ")
	return buf
}

func (o *userListS) InfoPrint() {
	fmt.Println(string(o.InfoJSON()))
}

func (o *userListS) AddListener(dl binding.DataListener) {
	// fmt.Println("UserList AddListener")
	if o.dataListener == nil {
		o.dataListener = map[binding.DataListener]bool{}
	}
	o.dataListener[dl] = true
}

func (o *userListS) RemoveListener(dl binding.DataListener) {
	// fmt.Println("UserList RemoveListener")
	delete(o.dataListener, dl)
}

func (o *userListS) GetItem(index int) (binding.DataItem, error) {
	// fmt.Println("UserList GetItem")
	return o.M[o.IDs[index]], nil
}

func (o *userListS) Length() int {
	// fmt.Println("UserList Length")
	return len(o.IDs)
}

//---

func UserList(where, order string, offset, limit int) userList {

	response := &userListS{
		query: req_listQueryS{
			Where:  where,
			Order:  order,
			Offset: offset,
			Limit:  limit,
		},
	}

	if where == "nil" {
		return response
	}

	response.Refresh()
	return response
}

func (o *userListS) SetWhere(where string) out.Info {
	o.query = req_listQueryS{
		Where: where,
	}
	return o.Refresh()
}

func (o *userListS) SetOrder(order string) out.Info {
	o.query = req_listQueryS{
		Order: order,
	}
	return o.Refresh()
}

func (o *userListS) SetOffset(offset int) out.Info {
	o.query = req_listQueryS{
		Offset: offset,
	}
	return o.Refresh()
}

func (o *userListS) SetLimit(limit int) out.Info {
	o.query = req_listQueryS{
		Limit: limit,
	}
	return o.Refresh()
}

func (o *userListS) First() User {
	for _, obj := range o.M {
		return out.CatchError(obj, nil)
	}

	res := &userS{}
	res.InfoAddTrace(out.NotFound, "", 0)
	return res
}

func (o *userListS) Iter() []User {

	if o.NotValid() {
		return nil
	}

	res := []User{}
	for _, id := range o.IDs {
		res = append(res, out.CatchError(o.M[id], nil))
	}
	return res
}

func (o *userListS) Refresh() out.Info {

	if o.query.Where == "nil" {
		return o
	}

	response := &userListS{
		query:        o.query,
		IDs:          []string{},
		IDtoIdx:      map[string]int{},
		M:            map[string]*userS{},
		dataListener: o.dataListener,
	}

	client.call(
		"UserList",
		o.query,
		response,
	)
	*o = *response

	for dl := range o.dataListener {
		// fmt.Println(">>>>>>>>>>>>>>>>>> dataListener", dl)
		dl.DataChanged()
	}
	return o
}

func (o *userListS) GetByID(id string) User {
	return out.CatchError(o.M[id], nil)
}

//---
