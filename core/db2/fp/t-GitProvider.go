package fp

// This file is automatically generated, manual editing is not recommended.

import (
	"encoding/json"
	"fmt"
	"time"

	"fyne.io/fyne/v2/data/binding"
	"github.com/lukx33/lwhelper"
	"github.com/lukx33/lwhelper/out"
)

var tmpGitProvider = lwhelper.ID()

type GitProvider interface {
	NotValid() bool
	InfoAddTrace(result out.ResultT, msg string, skipFrames int)
	InfoAddCause(parent out.Info) out.Info
	InfoAddVar(name string, value any) out.Info
	InfoResult() out.ResultT
	InfoTraces() []out.TraceS
	InfoLastTrace() out.TraceS
	InfoJSON() []byte
	InfoPrint()

	ID() string
	Created() int64
	Updated() int64

	Enabled() bool
	SetEnabled(value bool) out.Info
	Login() string
	SetLogin(value string) out.Info
	Name() string
	SetName(value string) out.Info
	Organization() Organization
	SetOrganization(value Organization) out.Info
	Password() string
	SetPassword(value string) out.Info
	PrivateKey() string
	SetPrivateKey(value string) out.Info
	PublicKey() string
	SetPublicKey(value string) out.Info
	Timoni_Token() string
	SetTimoni_Token(value string) out.Info
	URL() string
	SetURL(value string) out.Info
	Variant() GitProviderVariantT
	SetVariant(value GitProviderVariantT) out.Info
	Delete() out.Info
}
type gitProviderS struct {
	out.DontUseMeInfoS

	IDC      string
	CreatedC int64
	UpdatedC int64

	EnabledC      bool
	LoginC        string
	NameC         string
	OrganizationC string
	PasswordC     string
	PrivateKeyC   string
	PublicKeyC    string
	Timoni_TokenC string
	URLC          string
	VariantC      GitProviderVariantT
}

func (o *gitProviderS) dataMapEN() map[string]string {
	return map[string]string{
		"ID":           o.IDC,
		"Created":      fmt.Sprint(o.CreatedC),
		"Updated":      fmt.Sprint(o.UpdatedC),
		"Enabled":      fmt.Sprint(o.EnabledC),
		"Login":        o.LoginC,
		"Name":         o.NameC,
		"Organization": o.OrganizationC,
		"Password":     o.PasswordC,
		"PrivateKey":   o.PrivateKeyC,
		"PublicKey":    o.PublicKeyC,
		"Timoni_Token": o.Timoni_TokenC,
		"URL":          o.URLC,
		"Variant":      o.VariantC.EN(),
	}
}

// ---

func (o *gitProviderS) AddListener(l binding.DataListener) {
	fmt.Println("GitProvider AddListener")
}

func (o *gitProviderS) RemoveListener(l binding.DataListener) {
	fmt.Println("GitProvider RemoveListener")
}

// ---

func (o *gitProviderS) InfoJSON() []byte {
	buf, _ := json.MarshalIndent(o, "", "  ")
	return buf
}

func (o *gitProviderS) InfoPrint() {
	fmt.Println(string(o.InfoJSON()))
}

// ---
// ID

func (o *gitProviderS) ID() string {
	if o == nil {
		return ""
	}
	return o.IDC
}

// ---
// Created

func (o *gitProviderS) Created() int64 {
	if o == nil {
		return 0
	}
	return o.CreatedC
}

// ---
// Updated

func (o *gitProviderS) Updated() int64 {
	if o == nil {
		return 0
	}
	return o.UpdatedC
}

// ---
// Enabled

func (o *gitProviderS) Enabled() bool {
	return o.EnabledC
}

func (o *gitProviderS) SetEnabled(value bool) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	response := new(out.DontUseMeInfoS)
	client.call(
		"GitProviderSetEnabled",
		req_setBoolS{
			ID:       o.IDC,
			NewValue: value,
		},
		response,
	)
	if response.NotValid() {
		return response
	}

	o.EnabledC = value
	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// Login

func (o *gitProviderS) Login() string {
	return o.LoginC
}

func (o *gitProviderS) SetLogin(value string) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	response := new(out.DontUseMeInfoS)
	client.call(
		"GitProviderSetLogin",
		req_setStringS{
			ID:       o.IDC,
			NewValue: value,
		},
		response,
	)
	if response.NotValid() {
		return response
	}

	o.LoginC = value
	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// Name

func (o *gitProviderS) Name() string {
	return o.NameC
}

func (o *gitProviderS) SetName(value string) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	response := new(out.DontUseMeInfoS)
	client.call(
		"GitProviderSetName",
		req_setStringS{
			ID:       o.IDC,
			NewValue: value,
		},
		response,
	)
	if response.NotValid() {
		return response
	}

	o.NameC = value
	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// Organization

func (o *gitProviderS) Organization() Organization {
	return OrganizationGetByID(o.OrganizationC)
}

func (o *gitProviderS) SetOrganization(value Organization) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	response := new(out.DontUseMeInfoS)
	client.call(
		"GitProviderSetOrganization",
		req_setRelationS{
			ID:     o.IDC,
			NewKey: value.ID(),
		},
		response,
	)
	if response.NotValid() {
		return response
	}

	o.OrganizationC = value.ID()
	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// Password

func (o *gitProviderS) Password() string {
	return o.PasswordC
}

func (o *gitProviderS) SetPassword(value string) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	response := new(out.DontUseMeInfoS)
	client.call(
		"GitProviderSetPassword",
		req_setStringS{
			ID:       o.IDC,
			NewValue: value,
		},
		response,
	)
	if response.NotValid() {
		return response
	}

	o.PasswordC = value
	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// PrivateKey

func (o *gitProviderS) PrivateKey() string {
	return o.PrivateKeyC
}

func (o *gitProviderS) SetPrivateKey(value string) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	response := new(out.DontUseMeInfoS)
	client.call(
		"GitProviderSetPrivateKey",
		req_setStringS{
			ID:       o.IDC,
			NewValue: value,
		},
		response,
	)
	if response.NotValid() {
		return response
	}

	o.PrivateKeyC = value
	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// PublicKey

func (o *gitProviderS) PublicKey() string {
	return o.PublicKeyC
}

func (o *gitProviderS) SetPublicKey(value string) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	response := new(out.DontUseMeInfoS)
	client.call(
		"GitProviderSetPublicKey",
		req_setStringS{
			ID:       o.IDC,
			NewValue: value,
		},
		response,
	)
	if response.NotValid() {
		return response
	}

	o.PublicKeyC = value
	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// Timoni_Token

func (o *gitProviderS) Timoni_Token() string {
	return o.Timoni_TokenC
}

func (o *gitProviderS) SetTimoni_Token(value string) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	response := new(out.DontUseMeInfoS)
	client.call(
		"GitProviderSetTimoni_Token",
		req_setStringS{
			ID:       o.IDC,
			NewValue: value,
		},
		response,
	)
	if response.NotValid() {
		return response
	}

	o.Timoni_TokenC = value
	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// URL

func (o *gitProviderS) URL() string {
	return o.URLC
}

func (o *gitProviderS) SetURL(value string) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	response := new(out.DontUseMeInfoS)
	client.call(
		"GitProviderSetURL",
		req_setStringS{
			ID:       o.IDC,
			NewValue: value,
		},
		response,
	)
	if response.NotValid() {
		return response
	}

	o.URLC = value
	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// Variant

func (o *gitProviderS) Variant() GitProviderVariantT {
	return o.VariantC
}

func (o *gitProviderS) SetVariant(value GitProviderVariantT) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	response := new(out.DontUseMeInfoS)
	client.call(
		"GitProviderSetVariant",
		req_setUInt16S{
			ID:       o.IDC,
			NewValue: uint16(value),
		},
		response,
	)
	if response.NotValid() {
		return response
	}

	o.VariantC = value
	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---

func GitProviderGetByID(ID string) GitProvider {

	response := &gitProviderS{}
	client.call(
		"GitProviderGetByID",
		req_oneS{
			ID: ID,
		},
		response,
	)

	return response
}

// ---

func (o *gitProviderS) Delete() out.Info {

	response := new(out.DontUseMeInfoS)
	client.call(
		"GitProviderDelete",
		req_oneS{
			ID: o.ID(),
		},
		response,
	)

	return response
}

// ---

type req_GitProviderCreateS struct {
	Name         string
	Organization string
	Variant      GitProviderVariantT
}

func GitProviderCreate(
	Name string,
	Organization Organization,
	Variant GitProviderVariantT,

) GitProvider {

	response := &gitProviderS{}
	client.call(
		"GitProviderCreate",
		req_GitProviderCreateS{
			Name:         Name,
			Organization: Organization.ID(),
			Variant:      Variant,
		},
		response,
	)
	return response
}

// ----------------------------------------------------- table list:

type gitProviderList interface {
	NotValid() bool
	InfoAddTrace(result out.ResultT, msg string, skipFrames int)
	InfoAddCause(parent out.Info) out.Info
	InfoAddVar(name string, value any) out.Info
	InfoResult() out.ResultT
	InfoTraces() []out.TraceS
	InfoLastTrace() out.TraceS
	InfoJSON() []byte
	InfoPrint()

	Length() int
	First() GitProvider
	GetByID(id string) GitProvider
	Iter() []GitProvider
	Refresh() out.Info
	SetWhere(where string) out.Info
	SetOrder(order string) out.Info
	SetOffset(offset int) out.Info
	SetLimit(limit int) out.Info

	AddListener(dl binding.DataListener)
	RemoveListener(dl binding.DataListener)
	GetItem(index int) (binding.DataItem, error)
}

type gitProviderListS struct {
	out.DontUseMeInfoS

	query   req_listQueryS
	IDs     []string
	IDtoIdx map[string]int
	M       map[string]*gitProviderS

	dataListener map[binding.DataListener]bool
}

func (o *gitProviderListS) InfoJSON() []byte {
	buf, _ := json.MarshalIndent(o, "", "  ")
	return buf
}

func (o *gitProviderListS) InfoPrint() {
	fmt.Println(string(o.InfoJSON()))
}

func (o *gitProviderListS) AddListener(dl binding.DataListener) {
	// fmt.Println("GitProviderList AddListener")
	if o.dataListener == nil {
		o.dataListener = map[binding.DataListener]bool{}
	}
	o.dataListener[dl] = true
}

func (o *gitProviderListS) RemoveListener(dl binding.DataListener) {
	// fmt.Println("GitProviderList RemoveListener")
	delete(o.dataListener, dl)
}

func (o *gitProviderListS) GetItem(index int) (binding.DataItem, error) {
	// fmt.Println("GitProviderList GetItem")
	return o.M[o.IDs[index]], nil
}

func (o *gitProviderListS) Length() int {
	// fmt.Println("GitProviderList Length")
	return len(o.IDs)
}

//---

func GitProviderList(where, order string, offset, limit int) gitProviderList {

	response := &gitProviderListS{
		query: req_listQueryS{
			Where:  where,
			Order:  order,
			Offset: offset,
			Limit:  limit,
		},
	}

	if where == "nil" {
		return response
	}

	response.Refresh()
	return response
}

func (o *gitProviderListS) SetWhere(where string) out.Info {
	o.query = req_listQueryS{
		Where: where,
	}
	return o.Refresh()
}

func (o *gitProviderListS) SetOrder(order string) out.Info {
	o.query = req_listQueryS{
		Order: order,
	}
	return o.Refresh()
}

func (o *gitProviderListS) SetOffset(offset int) out.Info {
	o.query = req_listQueryS{
		Offset: offset,
	}
	return o.Refresh()
}

func (o *gitProviderListS) SetLimit(limit int) out.Info {
	o.query = req_listQueryS{
		Limit: limit,
	}
	return o.Refresh()
}

func (o *gitProviderListS) First() GitProvider {
	for _, obj := range o.M {
		return out.CatchError(obj, nil)
	}

	res := &gitProviderS{}
	res.InfoAddTrace(out.NotFound, "", 0)
	return res
}

func (o *gitProviderListS) Iter() []GitProvider {

	if o.NotValid() {
		return nil
	}

	res := []GitProvider{}
	for _, id := range o.IDs {
		res = append(res, out.CatchError(o.M[id], nil))
	}
	return res
}

func (o *gitProviderListS) Refresh() out.Info {

	if o.query.Where == "nil" {
		return o
	}

	response := &gitProviderListS{
		query:        o.query,
		IDs:          []string{},
		IDtoIdx:      map[string]int{},
		M:            map[string]*gitProviderS{},
		dataListener: o.dataListener,
	}

	client.call(
		"GitProviderList",
		o.query,
		response,
	)
	*o = *response

	for dl := range o.dataListener {
		// fmt.Println(">>>>>>>>>>>>>>>>>> dataListener", dl)
		dl.DataChanged()
	}
	return o
}

func (o *gitProviderListS) GetByID(id string) GitProvider {
	return out.CatchError(o.M[id], nil)
}

//---

func (o *gitProviderListS) GetByName(name string) GitProvider {

	for _, obj := range o.M {
		if obj.NameC == name {
			return out.CatchError(obj, nil)
		}
	}

	res := &gitProviderS{}
	res.InfoAddTrace(out.NotFound, "", 0)
	return res
}
