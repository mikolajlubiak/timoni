package fp

// This file is automatically generated, manual editing is not recommended.

import (
	"encoding/json"
	"fmt"
	"time"

	"fyne.io/fyne/v2/data/binding"
	"github.com/lukx33/lwhelper"
	"github.com/lukx33/lwhelper/out"
)

var tmpRelease = lwhelper.ID()

type Release interface {
	NotValid() bool
	InfoAddTrace(result out.ResultT, msg string, skipFrames int)
	InfoAddCause(parent out.Info) out.Info
	InfoAddVar(name string, value any) out.Info
	InfoResult() out.ResultT
	InfoTraces() []out.TraceS
	InfoLastTrace() out.TraceS
	InfoJSON() []byte
	InfoPrint()

	ID() string
	Created() int64
	Updated() int64

	BuildSuccess() bool
	SetBuildSuccess(value bool) out.Info
	GitTag() string
	SetGitTag(value string) out.Info
	Public() bool
	SetPublic(value bool) out.Info
	Delete() out.Info
}
type releaseS struct {
	out.DontUseMeInfoS

	IDC      string
	CreatedC int64
	UpdatedC int64

	BuildSuccessC bool
	GitTagC       string
	PublicC       bool
}

func (o *releaseS) dataMapEN() map[string]string {
	return map[string]string{
		"ID":           o.IDC,
		"Created":      fmt.Sprint(o.CreatedC),
		"Updated":      fmt.Sprint(o.UpdatedC),
		"BuildSuccess": fmt.Sprint(o.BuildSuccessC),
		"GitTag":       o.GitTagC,
		"Public":       fmt.Sprint(o.PublicC),
	}
}

// ---

func (o *releaseS) AddListener(l binding.DataListener) {
	fmt.Println("Release AddListener")
}

func (o *releaseS) RemoveListener(l binding.DataListener) {
	fmt.Println("Release RemoveListener")
}

// ---

func (o *releaseS) InfoJSON() []byte {
	buf, _ := json.MarshalIndent(o, "", "  ")
	return buf
}

func (o *releaseS) InfoPrint() {
	fmt.Println(string(o.InfoJSON()))
}

// ---
// ID

func (o *releaseS) ID() string {
	if o == nil {
		return ""
	}
	return o.IDC
}

// ---
// Created

func (o *releaseS) Created() int64 {
	if o == nil {
		return 0
	}
	return o.CreatedC
}

// ---
// Updated

func (o *releaseS) Updated() int64 {
	if o == nil {
		return 0
	}
	return o.UpdatedC
}

// ---
// BuildSuccess

func (o *releaseS) BuildSuccess() bool {
	return o.BuildSuccessC
}

func (o *releaseS) SetBuildSuccess(value bool) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	response := new(out.DontUseMeInfoS)
	client.call(
		"ReleaseSetBuildSuccess",
		req_setBoolS{
			ID:       o.IDC,
			NewValue: value,
		},
		response,
	)
	if response.NotValid() {
		return response
	}

	o.BuildSuccessC = value
	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// GitTag

func (o *releaseS) GitTag() string {
	return o.GitTagC
}

func (o *releaseS) SetGitTag(value string) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	response := new(out.DontUseMeInfoS)
	client.call(
		"ReleaseSetGitTag",
		req_setStringS{
			ID:       o.IDC,
			NewValue: value,
		},
		response,
	)
	if response.NotValid() {
		return response
	}

	o.GitTagC = value
	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// Public

func (o *releaseS) Public() bool {
	return o.PublicC
}

func (o *releaseS) SetPublic(value bool) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	response := new(out.DontUseMeInfoS)
	client.call(
		"ReleaseSetPublic",
		req_setBoolS{
			ID:       o.IDC,
			NewValue: value,
		},
		response,
	)
	if response.NotValid() {
		return response
	}

	o.PublicC = value
	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---

func ReleaseGetByID(ID string) Release {

	response := &releaseS{}
	client.call(
		"ReleaseGetByID",
		req_oneS{
			ID: ID,
		},
		response,
	)

	return response
}

// ---

func ReleaseGetByGitTag(GitTag string) Release {

	response := &releaseS{}
	client.call(
		"ReleaseGetByGitTag",
		req_oneS{
			ID: GitTag,
		},
		response,
	)

	return response
}

// ---

func (o *releaseS) Delete() out.Info {

	response := new(out.DontUseMeInfoS)
	client.call(
		"ReleaseDelete",
		req_oneS{
			ID: o.ID(),
		},
		response,
	)

	return response
}

// ---

type req_ReleaseCreateS struct {
	BuildSuccess bool
	GitTag       string
	Public       bool
}

func ReleaseCreate(
	BuildSuccess bool,
	GitTag string,
	Public bool,

) Release {

	response := &releaseS{}
	client.call(
		"ReleaseCreate",
		req_ReleaseCreateS{
			BuildSuccess: BuildSuccess,
			GitTag:       GitTag,
			Public:       Public,
		},
		response,
	)
	return response
}

// ----------------------------------------------------- table list:

type releaseList interface {
	NotValid() bool
	InfoAddTrace(result out.ResultT, msg string, skipFrames int)
	InfoAddCause(parent out.Info) out.Info
	InfoAddVar(name string, value any) out.Info
	InfoResult() out.ResultT
	InfoTraces() []out.TraceS
	InfoLastTrace() out.TraceS
	InfoJSON() []byte
	InfoPrint()

	Length() int
	First() Release
	GetByID(id string) Release
	Iter() []Release
	Refresh() out.Info
	SetWhere(where string) out.Info
	SetOrder(order string) out.Info
	SetOffset(offset int) out.Info
	SetLimit(limit int) out.Info

	AddListener(dl binding.DataListener)
	RemoveListener(dl binding.DataListener)
	GetItem(index int) (binding.DataItem, error)
}

type releaseListS struct {
	out.DontUseMeInfoS

	query   req_listQueryS
	IDs     []string
	IDtoIdx map[string]int
	M       map[string]*releaseS

	dataListener map[binding.DataListener]bool
}

func (o *releaseListS) InfoJSON() []byte {
	buf, _ := json.MarshalIndent(o, "", "  ")
	return buf
}

func (o *releaseListS) InfoPrint() {
	fmt.Println(string(o.InfoJSON()))
}

func (o *releaseListS) AddListener(dl binding.DataListener) {
	// fmt.Println("ReleaseList AddListener")
	if o.dataListener == nil {
		o.dataListener = map[binding.DataListener]bool{}
	}
	o.dataListener[dl] = true
}

func (o *releaseListS) RemoveListener(dl binding.DataListener) {
	// fmt.Println("ReleaseList RemoveListener")
	delete(o.dataListener, dl)
}

func (o *releaseListS) GetItem(index int) (binding.DataItem, error) {
	// fmt.Println("ReleaseList GetItem")
	return o.M[o.IDs[index]], nil
}

func (o *releaseListS) Length() int {
	// fmt.Println("ReleaseList Length")
	return len(o.IDs)
}

//---

func ReleaseList(where, order string, offset, limit int) releaseList {

	response := &releaseListS{
		query: req_listQueryS{
			Where:  where,
			Order:  order,
			Offset: offset,
			Limit:  limit,
		},
	}

	if where == "nil" {
		return response
	}

	response.Refresh()
	return response
}

func (o *releaseListS) SetWhere(where string) out.Info {
	o.query = req_listQueryS{
		Where: where,
	}
	return o.Refresh()
}

func (o *releaseListS) SetOrder(order string) out.Info {
	o.query = req_listQueryS{
		Order: order,
	}
	return o.Refresh()
}

func (o *releaseListS) SetOffset(offset int) out.Info {
	o.query = req_listQueryS{
		Offset: offset,
	}
	return o.Refresh()
}

func (o *releaseListS) SetLimit(limit int) out.Info {
	o.query = req_listQueryS{
		Limit: limit,
	}
	return o.Refresh()
}

func (o *releaseListS) First() Release {
	for _, obj := range o.M {
		return out.CatchError(obj, nil)
	}

	res := &releaseS{}
	res.InfoAddTrace(out.NotFound, "", 0)
	return res
}

func (o *releaseListS) Iter() []Release {

	if o.NotValid() {
		return nil
	}

	res := []Release{}
	for _, id := range o.IDs {
		res = append(res, out.CatchError(o.M[id], nil))
	}
	return res
}

func (o *releaseListS) Refresh() out.Info {

	if o.query.Where == "nil" {
		return o
	}

	response := &releaseListS{
		query:        o.query,
		IDs:          []string{},
		IDtoIdx:      map[string]int{},
		M:            map[string]*releaseS{},
		dataListener: o.dataListener,
	}

	client.call(
		"ReleaseList",
		o.query,
		response,
	)
	*o = *response

	for dl := range o.dataListener {
		// fmt.Println(">>>>>>>>>>>>>>>>>> dataListener", dl)
		dl.DataChanged()
	}
	return o
}

func (o *releaseListS) GetByID(id string) Release {
	return out.CatchError(o.M[id], nil)
}

//---
