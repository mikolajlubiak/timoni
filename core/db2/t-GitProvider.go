package db2

// This file is automatically generated, manual editing is not recommended.

import (
	"encoding/json"
	"fmt"
	"time"

	"fyne.io/fyne/v2/data/binding"
	"github.com/lukx33/lwhelper"
	"github.com/lukx33/lwhelper/out"
	"gorm.io/gorm"
)

var tmpGitProvider = lwhelper.ID()

type GitProvider interface {
	NotValid() bool
	InfoAddTrace(result out.ResultT, msg string, skipFrames int)
	InfoAddCause(parent out.Info) out.Info
	InfoAddVar(name string, value any) out.Info
	InfoResult() out.ResultT
	InfoTraces() []out.TraceS
	InfoLastTrace() out.TraceS
	InfoJSON() []byte
	InfoPrint()

	ID() string
	Created() int64
	Updated() int64

	Enabled() bool
	SetEnabled(value bool) out.Info
	Login() string
	SetLogin(value string) out.Info
	Name() string
	SetName(value string) out.Info
	Organization() Organization
	SetOrganization(value Organization) out.Info
	Password() string
	SetPassword(value string) out.Info
	PrivateKey() string
	SetPrivateKey(value string) out.Info
	PublicKey() string
	SetPublicKey(value string) out.Info
	Timoni_Token() string
	SetTimoni_Token(value string) out.Info
	URL() string
	SetURL(value string) out.Info
	Variant() GitProviderVariantT
	SetVariant(value GitProviderVariantT) out.Info
	Delete() out.Info
}
type gitProviderS struct {
	out.DontUseMeInfoS `gorm:"-"`

	IDC      string `gorm:"column:ID;primaryKey"`
	CreatedC int64  `gorm:"column:Created;autoCreateTime"`
	UpdatedC int64  `gorm:"column:Updated;autoUpdateTime"`

	EnabledC      bool                `gorm:"column:Enabled"`
	LoginC        string              `gorm:"column:Login"`
	NameC         string              `gorm:"column:Name"`
	OrganizationC string              `gorm:"column:Organization"`
	PasswordC     string              `gorm:"column:Password"`
	PrivateKeyC   string              `gorm:"column:PrivateKey"`
	PublicKeyC    string              `gorm:"column:PublicKey"`
	Timoni_TokenC string              `gorm:"column:Timoni_Token"`
	URLC          string              `gorm:"column:URL"`
	VariantC      GitProviderVariantT `gorm:"column:Variant"`
}

func (gitProviderS) TableName() string {
	return "GitProvider"
}

// ---

func (o *gitProviderS) AfterFind(tx *gorm.DB) error {
	return nil
}

// ---

func (o *gitProviderS) InfoJSON() []byte {
	buf, _ := json.MarshalIndent(o, "", "  ")
	return buf
}

func (o *gitProviderS) InfoPrint() {
	fmt.Println(string(o.InfoJSON()))
}

func (o *gitProviderS) AddListener(l binding.DataListener) {
	fmt.Println("GitProvider AddListener")
}

func (o *gitProviderS) RemoveListener(l binding.DataListener) {
	fmt.Println("GitProvider RemoveListener")
}

func (o *gitProviderS) Delete() out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	dbLock.Lock()
	defer dbLock.Unlock()

	err := dbConnection.Where("ID = ?", o.IDC).Delete(&gitProviderS{}).Error
	if err != nil {
		return out.New(err)
	}

	return out.NewSuccess()
}

func gitProviderCreateOrUpdate(srcB []byte) {

	src := &gitProviderS{}
	json.Unmarshal(srcB, src)
	id := src.IDC
	// src.InfoPrint()

	if id == "" {
		panic("cos tu jest nie tak")
	}

	srcMap := map[string]any{}
	json.Unmarshal(src.InfoJSON(), &srcMap)
	delete(srcMap, "trace")
	delete(srcMap, "result")
	delete(srcMap, "vars")
	delete(srcMap, "IDC")
	// out.PrintJSON(srcMap)

	dbLock.Lock()
	defer dbLock.Unlock()

	var exists bool
	if out.New(dbConnection.Model(&gitProviderS{}).Select("count(*) > 0").
		Where("id = ?", id).Find(&exists).Error).NotValid() {
		return
	}
	if !exists {
		// new item, creating
		// fmt.Println("new item")
		out.New(dbConnection.Create(src).Error)
		return
	}

	// looking for changes
	// fmt.Println("changes")
	out.New(dbConnection.Model(&gitProviderS{}).Where("ID = ?", id).Updates(srcMap).Error)
}

// ---
// ID

func (o *gitProviderS) ID() string {
	if o == nil {
		return ""
	}
	return o.IDC
}

// ---
// Created

func (o *gitProviderS) Created() int64 {
	if o == nil {
		return 0
	}
	return o.CreatedC
}

// ---
// Updated

func (o *gitProviderS) Updated() int64 {
	if o == nil {
		return 0
	}
	return o.UpdatedC
}

// ---
// Enabled

func (o *gitProviderS) Enabled() bool {
	if o == nil {
		return false
	}
	return o.EnabledC
}

func (o *gitProviderS) SetEnabled(value bool) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	// TODO: if current value == new value, then there is no point in changing anything

	oldValue := o.EnabledC
	o.EnabledC = value

	dbLock.Lock()
	defer dbLock.Unlock()

	err := dbConnection.Model(&gitProviderS{}).Where("ID = ?", o.IDC).Update("Enabled", value).Error
	if err != nil {
		o.EnabledC = oldValue
		return out.New(err)
	}

	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// Login

func (o *gitProviderS) Login() string {
	if o == nil {
		return ""
	}
	return o.LoginC
}

func (o *gitProviderS) SetLogin(value string) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	// TODO: if current value == new value, then there is no point in changing anything

	oldValue := o.LoginC
	o.LoginC = value

	dbLock.Lock()
	defer dbLock.Unlock()

	err := dbConnection.Model(&gitProviderS{}).Where("ID = ?", o.IDC).Update("Login", value).Error
	if err != nil {
		o.LoginC = oldValue
		return out.New(err)
	}

	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// Name

func (o *gitProviderS) Name() string {
	if o == nil {
		return ""
	}
	return o.NameC
}

func (o *gitProviderS) SetName(value string) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	// TODO: if current value == new value, then there is no point in changing anything

	oldValue := o.NameC
	o.NameC = value

	dbLock.Lock()
	defer dbLock.Unlock()

	err := dbConnection.Model(&gitProviderS{}).Where("ID = ?", o.IDC).Update("Name", value).Error
	if err != nil {
		o.NameC = oldValue
		return out.New(err)
	}

	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// Organization

func (o *gitProviderS) Organization() Organization {
	if o == nil {
		return nil
	}
	return OrganizationGetByID(o.OrganizationC)
}

func (o *gitProviderS) SetOrganization(value Organization) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	// TODO: if current value == new value, then there is no point in changing anything

	oldValue := o.OrganizationC
	o.OrganizationC = value.ID()

	dbLock.Lock()
	defer dbLock.Unlock()

	err := dbConnection.Model(&gitProviderS{}).Where("ID = ?", o.IDC).Update("Organization", value.ID()).Error
	if err != nil {
		o.OrganizationC = oldValue
		return out.New(err)
	}

	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// Password

func (o *gitProviderS) Password() string {
	if o == nil {
		return ""
	}
	return o.PasswordC
}

func (o *gitProviderS) SetPassword(value string) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	// TODO: if current value == new value, then there is no point in changing anything

	oldValue := o.PasswordC
	o.PasswordC = value

	dbLock.Lock()
	defer dbLock.Unlock()

	err := dbConnection.Model(&gitProviderS{}).Where("ID = ?", o.IDC).Update("Password", value).Error
	if err != nil {
		o.PasswordC = oldValue
		return out.New(err)
	}

	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// PrivateKey

func (o *gitProviderS) PrivateKey() string {
	if o == nil {
		return ""
	}
	return o.PrivateKeyC
}

func (o *gitProviderS) SetPrivateKey(value string) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	// TODO: if current value == new value, then there is no point in changing anything

	oldValue := o.PrivateKeyC
	o.PrivateKeyC = value

	dbLock.Lock()
	defer dbLock.Unlock()

	err := dbConnection.Model(&gitProviderS{}).Where("ID = ?", o.IDC).Update("PrivateKey", value).Error
	if err != nil {
		o.PrivateKeyC = oldValue
		return out.New(err)
	}

	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// PublicKey

func (o *gitProviderS) PublicKey() string {
	if o == nil {
		return ""
	}
	return o.PublicKeyC
}

func (o *gitProviderS) SetPublicKey(value string) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	// TODO: if current value == new value, then there is no point in changing anything

	oldValue := o.PublicKeyC
	o.PublicKeyC = value

	dbLock.Lock()
	defer dbLock.Unlock()

	err := dbConnection.Model(&gitProviderS{}).Where("ID = ?", o.IDC).Update("PublicKey", value).Error
	if err != nil {
		o.PublicKeyC = oldValue
		return out.New(err)
	}

	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// Timoni_Token

func (o *gitProviderS) Timoni_Token() string {
	if o == nil {
		return ""
	}
	return o.Timoni_TokenC
}

func (o *gitProviderS) SetTimoni_Token(value string) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	// TODO: if current value == new value, then there is no point in changing anything

	oldValue := o.Timoni_TokenC
	o.Timoni_TokenC = value

	dbLock.Lock()
	defer dbLock.Unlock()

	err := dbConnection.Model(&gitProviderS{}).Where("ID = ?", o.IDC).Update("Timoni_Token", value).Error
	if err != nil {
		o.Timoni_TokenC = oldValue
		return out.New(err)
	}

	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// URL

func (o *gitProviderS) URL() string {
	if o == nil {
		return ""
	}
	return o.URLC
}

func (o *gitProviderS) SetURL(value string) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	// TODO: if current value == new value, then there is no point in changing anything

	oldValue := o.URLC
	o.URLC = value

	dbLock.Lock()
	defer dbLock.Unlock()

	err := dbConnection.Model(&gitProviderS{}).Where("ID = ?", o.IDC).Update("URL", value).Error
	if err != nil {
		o.URLC = oldValue
		return out.New(err)
	}

	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// Variant

func (o *gitProviderS) Variant() GitProviderVariantT {
	if o == nil {
		return 0
	}
	return o.VariantC
}

func (o *gitProviderS) SetVariant(value GitProviderVariantT) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	// TODO: if current value == new value, then there is no point in changing anything

	oldValue := o.VariantC
	o.VariantC = value

	dbLock.Lock()
	defer dbLock.Unlock()

	err := dbConnection.Model(&gitProviderS{}).Where("ID = ?", o.IDC).Update("Variant", value).Error
	if err != nil {
		o.VariantC = oldValue
		return out.New(err)
	}

	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ----------------------------------------------------- table list:

type gitProviderList interface {
	NotValid() bool
	InfoAddTrace(result out.ResultT, msg string, skipFrames int)
	InfoAddCause(parent out.Info) out.Info
	InfoAddVar(name string, value any) out.Info
	InfoResult() out.ResultT
	InfoTraces() []out.TraceS
	InfoLastTrace() out.TraceS
	InfoJSON() []byte
	InfoPrint()

	Length() int
	First() GitProvider
	GetByID(id string) GitProvider
	Iter() []GitProvider
	Refresh() out.Info
	SetWhere(where string) out.Info
	SetOrder(order string) out.Info
	SetOffset(offset int) out.Info
	SetLimit(limit int) out.Info

	AddListener(dl binding.DataListener)
	RemoveListener(dl binding.DataListener)
	GetItem(index int) (binding.DataItem, error)
}

type gitProviderListS struct {
	out.DontUseMeInfoS

	query        req_listQueryS
	M            map[string]*gitProviderS
	IDs          []string
	IDtoIdx      map[string]int
	dataListener map[binding.DataListener]bool
}

//---

func (o *gitProviderListS) InfoJSON() []byte {
	buf, _ := json.MarshalIndent(o, "", "  ")
	return buf
}

func (o *gitProviderListS) InfoPrint() {
	fmt.Println(string(o.InfoJSON()))
}

func (o *gitProviderListS) AddListener(dl binding.DataListener) {
	// fmt.Println("GitProviderList AddListener")
	if o.dataListener == nil {
		o.dataListener = map[binding.DataListener]bool{}
	}
	o.dataListener[dl] = true
}

func (o *gitProviderListS) RemoveListener(dl binding.DataListener) {
	// fmt.Println("GitProviderList RemoveListener")
	delete(o.dataListener, dl)
}

func (o *gitProviderListS) GetItem(index int) (binding.DataItem, error) {
	// fmt.Println("GitProviderList GetItem")
	return o.M[o.IDs[index]], nil
}

func (o *gitProviderListS) Length() int {
	// fmt.Println("GitProviderList Length")
	return len(o.IDs)
}

func (o *gitProviderListS) SetWhere(where string) out.Info {
	o.query = req_listQueryS{
		Where: where,
	}
	return o.Refresh()
}

func (o *gitProviderListS) SetOrder(order string) out.Info {
	o.query = req_listQueryS{
		Order: order,
	}
	return o.Refresh()
}

func (o *gitProviderListS) SetOffset(offset int) out.Info {
	o.query = req_listQueryS{
		Offset: offset,
	}
	return o.Refresh()
}

func (o *gitProviderListS) SetLimit(limit int) out.Info {
	o.query = req_listQueryS{
		Limit: limit,
	}
	return o.Refresh()
}

//---

func GitProviderList(where, order string, offset, limit int) gitProviderList {

	response := &gitProviderListS{
		query: req_listQueryS{
			Where:  where,
			Order:  order,
			Offset: offset,
			Limit:  limit,
		},
	}

	if where == "nil" {
		return response
	}

	response.Refresh()
	return response
}

func (o *gitProviderListS) Refresh() out.Info {

	if o.query.Where == "nil" {
		return o
	}

	res := &gitProviderListS{
		query:        o.query,
		IDs:          []string{},
		IDtoIdx:      map[string]int{},
		M:            map[string]*gitProviderS{},
		dataListener: o.dataListener,
	}

	dbLock.Lock()
	defer dbLock.Unlock()

	st := dbConnection.Model(&gitProviderS{})
	if o.query.Where != "" {
		st.Where(o.query.Where)
	}
	if o.query.Order == "" {
		o.query.Order = "Created"
	}
	if o.query.Limit == 0 {
		o.query.Limit = 30
	}

	responseList := []*gitProviderS{}
	if out.CatchError(res,
		st.Order(o.query.Order).Offset(o.query.Offset).Limit(o.query.Limit).Find(&responseList).Error,
	).NotValid() {
		return res
	}
	// out.PrintJSON(responseList)

	for idx, entry := range responseList {
		res.IDs = append(res.IDs, entry.IDC)
		res.IDtoIdx[entry.IDC] = idx
		res.M[entry.IDC] = entry
	}

	out.CatchError(res, nil)
	*o = *res

	for dl := range o.dataListener {
		// fmt.Println(">>>>>>>>>>>>>>>>>> dataListener", dl)
		dl.DataChanged()
	}
	return res
}

func (o *gitProviderListS) First() GitProvider {
	for _, obj := range o.M {
		return out.CatchError(obj, nil)
	}

	res := &gitProviderS{}
	res.InfoAddTrace(out.NotFound, "", 0)
	return res
}

func (o *gitProviderListS) GetByID(id string) GitProvider {
	res, exist := o.M[id]
	if !exist {
		res.InfoAddTrace(out.NotFound, "", 0)
		return res
	}
	return out.CatchError(res, nil)
}

func (o *gitProviderListS) Iter() []GitProvider {

	if o.NotValid() {
		return nil
	}

	res := []GitProvider{}
	for _, id := range o.IDs {
		res = append(res, out.CatchError(o.M[id], nil))
	}
	return res
}

// ---

func GitProviderGetByID(key string) GitProvider {

	res := &gitProviderS{}
	if key == "" {
		res.InfoAddTrace(out.NotFound, "", 0)
		return res
	}

	dbLock.Lock()
	defer dbLock.Unlock()

	out.CatchError(res, dbConnection.Where("ID = ?", key).First(res).Error)

	if res.NotValid() && res.InfoLastTrace().Message == "record not found" {
		res.Result = out.NotFound
	}

	return res
}

//---

func GitProviderCreate(
	Name string,
	Organization Organization,
	Variant GitProviderVariantT,
) GitProvider {

	// TODO: Input data validation

	now := time.Now()
	obj := &gitProviderS{
		IDC:           lwhelper.ID(),
		CreatedC:      now.Unix(),
		UpdatedC:      now.Unix(),
		NameC:         Name,
		OrganizationC: Organization.ID(),
		VariantC:      Variant,
	}

	obj.EnabledC = true

	// Saving data to the database
	dbLock.Lock()
	defer dbLock.Unlock()

	return out.CatchError(obj, dbConnection.Create(obj).Error)
}

//---
