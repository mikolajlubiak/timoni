package db2

// This file is automatically generated, manual editing is not recommended.

import (
	"encoding/json"
	"fmt"
	"time"

	"fyne.io/fyne/v2/data/binding"
	"github.com/lukx33/lwhelper"
	"github.com/lukx33/lwhelper/out"
	"gorm.io/gorm"
)

var tmpModuleState = lwhelper.ID()

type ModuleState interface {
	NotValid() bool
	InfoAddTrace(result out.ResultT, msg string, skipFrames int)
	InfoAddCause(parent out.Info) out.Info
	InfoAddVar(name string, value any) out.Info
	InfoResult() out.ResultT
	InfoTraces() []out.TraceS
	InfoLastTrace() out.TraceS
	InfoJSON() []byte
	InfoPrint()

	ID() string
	Created() int64
	Updated() int64

	Active() bool
	SetActive(value bool) out.Info
	Message() string
	SetMessage(value string) out.Info
	Name() string
	SetName(value string) out.Info
	SinceSec() int64
	SetSinceSec(value int64) out.Info
	State() StateT
	SetState(value StateT) out.Info
	Delete() out.Info
}
type moduleStateS struct {
	out.DontUseMeInfoS `gorm:"-"`

	IDC      string `gorm:"column:ID;primaryKey"`
	CreatedC int64  `gorm:"column:Created;autoCreateTime"`
	UpdatedC int64  `gorm:"column:Updated;autoUpdateTime"`

	ActiveC   bool   `gorm:"column:Active"`
	MessageC  string `gorm:"column:Message"`
	NameC     string `gorm:"column:Name"`
	SinceSecC int64  `gorm:"column:SinceSec"`
	StateC    StateT `gorm:"column:State"`
}

func (moduleStateS) TableName() string {
	return "ModuleState"
}

// ---

func (o *moduleStateS) AfterFind(tx *gorm.DB) error {
	return nil
}

// ---

func (o *moduleStateS) InfoJSON() []byte {
	buf, _ := json.MarshalIndent(o, "", "  ")
	return buf
}

func (o *moduleStateS) InfoPrint() {
	fmt.Println(string(o.InfoJSON()))
}

func (o *moduleStateS) AddListener(l binding.DataListener) {
	fmt.Println("ModuleState AddListener")
}

func (o *moduleStateS) RemoveListener(l binding.DataListener) {
	fmt.Println("ModuleState RemoveListener")
}

func (o *moduleStateS) Delete() out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	dbLock.Lock()
	defer dbLock.Unlock()

	err := dbConnection.Where("ID = ?", o.IDC).Delete(&moduleStateS{}).Error
	if err != nil {
		return out.New(err)
	}

	return out.NewSuccess()
}

func moduleStateCreateOrUpdate(srcB []byte) {

	src := &moduleStateS{}
	json.Unmarshal(srcB, src)
	id := src.IDC
	// src.InfoPrint()

	if id == "" {
		panic("cos tu jest nie tak")
	}

	srcMap := map[string]any{}
	json.Unmarshal(src.InfoJSON(), &srcMap)
	delete(srcMap, "trace")
	delete(srcMap, "result")
	delete(srcMap, "vars")
	delete(srcMap, "IDC")
	// out.PrintJSON(srcMap)

	dbLock.Lock()
	defer dbLock.Unlock()

	var exists bool
	if out.New(dbConnection.Model(&moduleStateS{}).Select("count(*) > 0").
		Where("id = ?", id).Find(&exists).Error).NotValid() {
		return
	}
	if !exists {
		// new item, creating
		// fmt.Println("new item")
		out.New(dbConnection.Create(src).Error)
		return
	}

	// looking for changes
	// fmt.Println("changes")
	out.New(dbConnection.Model(&moduleStateS{}).Where("ID = ?", id).Updates(srcMap).Error)
}

// ---
// ID

func (o *moduleStateS) ID() string {
	if o == nil {
		return ""
	}
	return o.IDC
}

// ---
// Created

func (o *moduleStateS) Created() int64 {
	if o == nil {
		return 0
	}
	return o.CreatedC
}

// ---
// Updated

func (o *moduleStateS) Updated() int64 {
	if o == nil {
		return 0
	}
	return o.UpdatedC
}

// ---
// Active

func (o *moduleStateS) Active() bool {
	if o == nil {
		return false
	}
	return o.ActiveC
}

func (o *moduleStateS) SetActive(value bool) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	// TODO: if current value == new value, then there is no point in changing anything

	oldValue := o.ActiveC
	o.ActiveC = value

	dbLock.Lock()
	defer dbLock.Unlock()

	err := dbConnection.Model(&moduleStateS{}).Where("ID = ?", o.IDC).Update("Active", value).Error
	if err != nil {
		o.ActiveC = oldValue
		return out.New(err)
	}

	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// Message

func (o *moduleStateS) Message() string {
	if o == nil {
		return ""
	}
	return o.MessageC
}

func (o *moduleStateS) SetMessage(value string) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	// TODO: if current value == new value, then there is no point in changing anything

	oldValue := o.MessageC
	o.MessageC = value

	dbLock.Lock()
	defer dbLock.Unlock()

	err := dbConnection.Model(&moduleStateS{}).Where("ID = ?", o.IDC).Update("Message", value).Error
	if err != nil {
		o.MessageC = oldValue
		return out.New(err)
	}

	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// Name

func (o *moduleStateS) Name() string {
	if o == nil {
		return ""
	}
	return o.NameC
}

func (o *moduleStateS) SetName(value string) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	// TODO: if current value == new value, then there is no point in changing anything

	oldValue := o.NameC
	o.NameC = value

	dbLock.Lock()
	defer dbLock.Unlock()

	err := dbConnection.Model(&moduleStateS{}).Where("ID = ?", o.IDC).Update("Name", value).Error
	if err != nil {
		o.NameC = oldValue
		return out.New(err)
	}

	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// SinceSec

func (o *moduleStateS) SinceSec() int64 {
	if o == nil {
		return 0
	}
	return o.SinceSecC
}

func (o *moduleStateS) SetSinceSec(value int64) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	// TODO: if current value == new value, then there is no point in changing anything

	oldValue := o.SinceSecC
	o.SinceSecC = value

	dbLock.Lock()
	defer dbLock.Unlock()

	err := dbConnection.Model(&moduleStateS{}).Where("ID = ?", o.IDC).Update("SinceSec", value).Error
	if err != nil {
		o.SinceSecC = oldValue
		return out.New(err)
	}

	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// State

func (o *moduleStateS) State() StateT {
	if o == nil {
		return 0
	}
	return o.StateC
}

func (o *moduleStateS) SetState(value StateT) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	// TODO: if current value == new value, then there is no point in changing anything

	oldValue := o.StateC
	o.StateC = value

	dbLock.Lock()
	defer dbLock.Unlock()

	err := dbConnection.Model(&moduleStateS{}).Where("ID = ?", o.IDC).Update("State", value).Error
	if err != nil {
		o.StateC = oldValue
		return out.New(err)
	}

	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ----------------------------------------------------- table list:

type moduleStateList interface {
	NotValid() bool
	InfoAddTrace(result out.ResultT, msg string, skipFrames int)
	InfoAddCause(parent out.Info) out.Info
	InfoAddVar(name string, value any) out.Info
	InfoResult() out.ResultT
	InfoTraces() []out.TraceS
	InfoLastTrace() out.TraceS
	InfoJSON() []byte
	InfoPrint()

	Length() int
	First() ModuleState
	GetByID(id string) ModuleState
	Iter() []ModuleState
	Refresh() out.Info
	SetWhere(where string) out.Info
	SetOrder(order string) out.Info
	SetOffset(offset int) out.Info
	SetLimit(limit int) out.Info

	AddListener(dl binding.DataListener)
	RemoveListener(dl binding.DataListener)
	GetItem(index int) (binding.DataItem, error)
}

type moduleStateListS struct {
	out.DontUseMeInfoS

	query        req_listQueryS
	M            map[string]*moduleStateS
	IDs          []string
	IDtoIdx      map[string]int
	dataListener map[binding.DataListener]bool
}

//---

func (o *moduleStateListS) InfoJSON() []byte {
	buf, _ := json.MarshalIndent(o, "", "  ")
	return buf
}

func (o *moduleStateListS) InfoPrint() {
	fmt.Println(string(o.InfoJSON()))
}

func (o *moduleStateListS) AddListener(dl binding.DataListener) {
	// fmt.Println("ModuleStateList AddListener")
	if o.dataListener == nil {
		o.dataListener = map[binding.DataListener]bool{}
	}
	o.dataListener[dl] = true
}

func (o *moduleStateListS) RemoveListener(dl binding.DataListener) {
	// fmt.Println("ModuleStateList RemoveListener")
	delete(o.dataListener, dl)
}

func (o *moduleStateListS) GetItem(index int) (binding.DataItem, error) {
	// fmt.Println("ModuleStateList GetItem")
	return o.M[o.IDs[index]], nil
}

func (o *moduleStateListS) Length() int {
	// fmt.Println("ModuleStateList Length")
	return len(o.IDs)
}

func (o *moduleStateListS) SetWhere(where string) out.Info {
	o.query = req_listQueryS{
		Where: where,
	}
	return o.Refresh()
}

func (o *moduleStateListS) SetOrder(order string) out.Info {
	o.query = req_listQueryS{
		Order: order,
	}
	return o.Refresh()
}

func (o *moduleStateListS) SetOffset(offset int) out.Info {
	o.query = req_listQueryS{
		Offset: offset,
	}
	return o.Refresh()
}

func (o *moduleStateListS) SetLimit(limit int) out.Info {
	o.query = req_listQueryS{
		Limit: limit,
	}
	return o.Refresh()
}

//---

func ModuleStateList(where, order string, offset, limit int) moduleStateList {

	response := &moduleStateListS{
		query: req_listQueryS{
			Where:  where,
			Order:  order,
			Offset: offset,
			Limit:  limit,
		},
	}

	if where == "nil" {
		return response
	}

	response.Refresh()
	return response
}

func (o *moduleStateListS) Refresh() out.Info {

	if o.query.Where == "nil" {
		return o
	}

	res := &moduleStateListS{
		query:        o.query,
		IDs:          []string{},
		IDtoIdx:      map[string]int{},
		M:            map[string]*moduleStateS{},
		dataListener: o.dataListener,
	}

	dbLock.Lock()
	defer dbLock.Unlock()

	st := dbConnection.Model(&moduleStateS{})
	if o.query.Where != "" {
		st.Where(o.query.Where)
	}
	if o.query.Order == "" {
		o.query.Order = "Created"
	}
	if o.query.Limit == 0 {
		o.query.Limit = 30
	}

	responseList := []*moduleStateS{}
	if out.CatchError(res,
		st.Order(o.query.Order).Offset(o.query.Offset).Limit(o.query.Limit).Find(&responseList).Error,
	).NotValid() {
		return res
	}
	// out.PrintJSON(responseList)

	for idx, entry := range responseList {
		res.IDs = append(res.IDs, entry.IDC)
		res.IDtoIdx[entry.IDC] = idx
		res.M[entry.IDC] = entry
	}

	out.CatchError(res, nil)
	*o = *res

	for dl := range o.dataListener {
		// fmt.Println(">>>>>>>>>>>>>>>>>> dataListener", dl)
		dl.DataChanged()
	}
	return res
}

func (o *moduleStateListS) First() ModuleState {
	for _, obj := range o.M {
		return out.CatchError(obj, nil)
	}

	res := &moduleStateS{}
	res.InfoAddTrace(out.NotFound, "", 0)
	return res
}

func (o *moduleStateListS) GetByID(id string) ModuleState {
	res, exist := o.M[id]
	if !exist {
		res.InfoAddTrace(out.NotFound, "", 0)
		return res
	}
	return out.CatchError(res, nil)
}

func (o *moduleStateListS) Iter() []ModuleState {

	if o.NotValid() {
		return nil
	}

	res := []ModuleState{}
	for _, id := range o.IDs {
		res = append(res, out.CatchError(o.M[id], nil))
	}
	return res
}

// ---

func ModuleStateGetByID(key string) ModuleState {

	res := &moduleStateS{}
	if key == "" {
		res.InfoAddTrace(out.NotFound, "", 0)
		return res
	}

	dbLock.Lock()
	defer dbLock.Unlock()

	out.CatchError(res, dbConnection.Where("ID = ?", key).First(res).Error)

	if res.NotValid() && res.InfoLastTrace().Message == "record not found" {
		res.Result = out.NotFound
	}

	return res
}

//---

func ModuleStateCreate(
	Message string,
	Name string,
) ModuleState {

	// TODO: Input data validation

	now := time.Now()
	obj := &moduleStateS{
		IDC:      lwhelper.ID(),
		CreatedC: now.Unix(),
		UpdatedC: now.Unix(),
		MessageC: Message,
		NameC:    Name,
	}

	obj.ActiveC = true
	obj.SinceSecC = 0
	obj.StateC = 2

	// Saving data to the database
	dbLock.Lock()
	defer dbLock.Unlock()

	return out.CatchError(obj, dbConnection.Create(obj).Error)
}

//---
