package db2

// This file is automatically generated, manual editing is not recommended.

import (
	"encoding/json"
	"fmt"
	"time"

	"fyne.io/fyne/v2/data/binding"
	"github.com/lukx33/lwhelper"
	"github.com/lukx33/lwhelper/out"
	"gorm.io/gorm"
)

var tmpCert = lwhelper.ID()

type Cert interface {
	NotValid() bool
	InfoAddTrace(result out.ResultT, msg string, skipFrames int)
	InfoAddCause(parent out.Info) out.Info
	InfoAddVar(name string, value any) out.Info
	InfoResult() out.ResultT
	InfoTraces() []out.TraceS
	InfoLastTrace() out.TraceS
	InfoJSON() []byte
	InfoPrint()

	ID() string
	Created() int64
	Updated() int64

	DomainName() string
	SetDomainName(value string) out.Info
	ExpirationTime() int64
	SetExpirationTime(value int64) out.Info
	Key() string
	SetKey(value string) out.Info
	Organization() Organization
	SetOrganization(value Organization) out.Info
	Pem() string
	SetPem(value string) out.Info
	Delete() out.Info
}
type certS struct {
	out.DontUseMeInfoS `gorm:"-"`

	IDC      string `gorm:"column:ID;primaryKey"`
	CreatedC int64  `gorm:"column:Created;autoCreateTime"`
	UpdatedC int64  `gorm:"column:Updated;autoUpdateTime"`

	DomainNameC     string `gorm:"column:DomainName"`
	ExpirationTimeC int64  `gorm:"column:ExpirationTime"`
	KeyC            string `gorm:"column:Key"`
	OrganizationC   string `gorm:"column:Organization"`
	PemC            string `gorm:"column:Pem"`
}

func (certS) TableName() string {
	return "Cert"
}

// ---

func (o *certS) AfterFind(tx *gorm.DB) error {
	return nil
}

// ---

func (o *certS) InfoJSON() []byte {
	buf, _ := json.MarshalIndent(o, "", "  ")
	return buf
}

func (o *certS) InfoPrint() {
	fmt.Println(string(o.InfoJSON()))
}

func (o *certS) AddListener(l binding.DataListener) {
	fmt.Println("Cert AddListener")
}

func (o *certS) RemoveListener(l binding.DataListener) {
	fmt.Println("Cert RemoveListener")
}

func (o *certS) Delete() out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	dbLock.Lock()
	defer dbLock.Unlock()

	err := dbConnection.Where("ID = ?", o.IDC).Delete(&certS{}).Error
	if err != nil {
		return out.New(err)
	}

	return out.NewSuccess()
}

func certCreateOrUpdate(srcB []byte) {

	src := &certS{}
	json.Unmarshal(srcB, src)
	id := src.IDC
	// src.InfoPrint()

	if id == "" {
		panic("cos tu jest nie tak")
	}

	srcMap := map[string]any{}
	json.Unmarshal(src.InfoJSON(), &srcMap)
	delete(srcMap, "trace")
	delete(srcMap, "result")
	delete(srcMap, "vars")
	delete(srcMap, "IDC")
	// out.PrintJSON(srcMap)

	dbLock.Lock()
	defer dbLock.Unlock()

	var exists bool
	if out.New(dbConnection.Model(&certS{}).Select("count(*) > 0").
		Where("id = ?", id).Find(&exists).Error).NotValid() {
		return
	}
	if !exists {
		// new item, creating
		// fmt.Println("new item")
		out.New(dbConnection.Create(src).Error)
		return
	}

	// looking for changes
	// fmt.Println("changes")
	out.New(dbConnection.Model(&certS{}).Where("ID = ?", id).Updates(srcMap).Error)
}

// ---
// ID

func (o *certS) ID() string {
	if o == nil {
		return ""
	}
	return o.IDC
}

// ---
// Created

func (o *certS) Created() int64 {
	if o == nil {
		return 0
	}
	return o.CreatedC
}

// ---
// Updated

func (o *certS) Updated() int64 {
	if o == nil {
		return 0
	}
	return o.UpdatedC
}

// ---
// DomainName

func (o *certS) DomainName() string {
	if o == nil {
		return ""
	}
	return o.DomainNameC
}

func (o *certS) SetDomainName(value string) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	// TODO: if current value == new value, then there is no point in changing anything

	oldValue := o.DomainNameC
	o.DomainNameC = value

	dbLock.Lock()
	defer dbLock.Unlock()

	err := dbConnection.Model(&certS{}).Where("ID = ?", o.IDC).Update("DomainName", value).Error
	if err != nil {
		o.DomainNameC = oldValue
		return out.New(err)
	}

	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// ExpirationTime

func (o *certS) ExpirationTime() int64 {
	if o == nil {
		return 0
	}
	return o.ExpirationTimeC
}

func (o *certS) SetExpirationTime(value int64) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	// TODO: if current value == new value, then there is no point in changing anything

	oldValue := o.ExpirationTimeC
	o.ExpirationTimeC = value

	dbLock.Lock()
	defer dbLock.Unlock()

	err := dbConnection.Model(&certS{}).Where("ID = ?", o.IDC).Update("ExpirationTime", value).Error
	if err != nil {
		o.ExpirationTimeC = oldValue
		return out.New(err)
	}

	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// Key

func (o *certS) Key() string {
	if o == nil {
		return ""
	}
	return o.KeyC
}

func (o *certS) SetKey(value string) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	// TODO: if current value == new value, then there is no point in changing anything

	oldValue := o.KeyC
	o.KeyC = value

	dbLock.Lock()
	defer dbLock.Unlock()

	err := dbConnection.Model(&certS{}).Where("ID = ?", o.IDC).Update("Key", value).Error
	if err != nil {
		o.KeyC = oldValue
		return out.New(err)
	}

	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// Organization

func (o *certS) Organization() Organization {
	if o == nil {
		return nil
	}
	return OrganizationGetByID(o.OrganizationC)
}

func (o *certS) SetOrganization(value Organization) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	// TODO: if current value == new value, then there is no point in changing anything

	oldValue := o.OrganizationC
	o.OrganizationC = value.ID()

	dbLock.Lock()
	defer dbLock.Unlock()

	err := dbConnection.Model(&certS{}).Where("ID = ?", o.IDC).Update("Organization", value.ID()).Error
	if err != nil {
		o.OrganizationC = oldValue
		return out.New(err)
	}

	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// Pem

func (o *certS) Pem() string {
	if o == nil {
		return ""
	}
	return o.PemC
}

func (o *certS) SetPem(value string) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	// TODO: if current value == new value, then there is no point in changing anything

	oldValue := o.PemC
	o.PemC = value

	dbLock.Lock()
	defer dbLock.Unlock()

	err := dbConnection.Model(&certS{}).Where("ID = ?", o.IDC).Update("Pem", value).Error
	if err != nil {
		o.PemC = oldValue
		return out.New(err)
	}

	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ----------------------------------------------------- table list:

type certList interface {
	NotValid() bool
	InfoAddTrace(result out.ResultT, msg string, skipFrames int)
	InfoAddCause(parent out.Info) out.Info
	InfoAddVar(name string, value any) out.Info
	InfoResult() out.ResultT
	InfoTraces() []out.TraceS
	InfoLastTrace() out.TraceS
	InfoJSON() []byte
	InfoPrint()

	Length() int
	First() Cert
	GetByID(id string) Cert
	Iter() []Cert
	Refresh() out.Info
	SetWhere(where string) out.Info
	SetOrder(order string) out.Info
	SetOffset(offset int) out.Info
	SetLimit(limit int) out.Info

	AddListener(dl binding.DataListener)
	RemoveListener(dl binding.DataListener)
	GetItem(index int) (binding.DataItem, error)
}

type certListS struct {
	out.DontUseMeInfoS

	query        req_listQueryS
	M            map[string]*certS
	IDs          []string
	IDtoIdx      map[string]int
	dataListener map[binding.DataListener]bool
}

//---

func (o *certListS) InfoJSON() []byte {
	buf, _ := json.MarshalIndent(o, "", "  ")
	return buf
}

func (o *certListS) InfoPrint() {
	fmt.Println(string(o.InfoJSON()))
}

func (o *certListS) AddListener(dl binding.DataListener) {
	// fmt.Println("CertList AddListener")
	if o.dataListener == nil {
		o.dataListener = map[binding.DataListener]bool{}
	}
	o.dataListener[dl] = true
}

func (o *certListS) RemoveListener(dl binding.DataListener) {
	// fmt.Println("CertList RemoveListener")
	delete(o.dataListener, dl)
}

func (o *certListS) GetItem(index int) (binding.DataItem, error) {
	// fmt.Println("CertList GetItem")
	return o.M[o.IDs[index]], nil
}

func (o *certListS) Length() int {
	// fmt.Println("CertList Length")
	return len(o.IDs)
}

func (o *certListS) SetWhere(where string) out.Info {
	o.query = req_listQueryS{
		Where: where,
	}
	return o.Refresh()
}

func (o *certListS) SetOrder(order string) out.Info {
	o.query = req_listQueryS{
		Order: order,
	}
	return o.Refresh()
}

func (o *certListS) SetOffset(offset int) out.Info {
	o.query = req_listQueryS{
		Offset: offset,
	}
	return o.Refresh()
}

func (o *certListS) SetLimit(limit int) out.Info {
	o.query = req_listQueryS{
		Limit: limit,
	}
	return o.Refresh()
}

//---

func CertList(where, order string, offset, limit int) certList {

	response := &certListS{
		query: req_listQueryS{
			Where:  where,
			Order:  order,
			Offset: offset,
			Limit:  limit,
		},
	}

	if where == "nil" {
		return response
	}

	response.Refresh()
	return response
}

func (o *certListS) Refresh() out.Info {

	if o.query.Where == "nil" {
		return o
	}

	res := &certListS{
		query:        o.query,
		IDs:          []string{},
		IDtoIdx:      map[string]int{},
		M:            map[string]*certS{},
		dataListener: o.dataListener,
	}

	dbLock.Lock()
	defer dbLock.Unlock()

	st := dbConnection.Model(&certS{})
	if o.query.Where != "" {
		st.Where(o.query.Where)
	}
	if o.query.Order == "" {
		o.query.Order = "Created"
	}
	if o.query.Limit == 0 {
		o.query.Limit = 30
	}

	responseList := []*certS{}
	if out.CatchError(res,
		st.Order(o.query.Order).Offset(o.query.Offset).Limit(o.query.Limit).Find(&responseList).Error,
	).NotValid() {
		return res
	}
	// out.PrintJSON(responseList)

	for idx, entry := range responseList {
		res.IDs = append(res.IDs, entry.IDC)
		res.IDtoIdx[entry.IDC] = idx
		res.M[entry.IDC] = entry
	}

	out.CatchError(res, nil)
	*o = *res

	for dl := range o.dataListener {
		// fmt.Println(">>>>>>>>>>>>>>>>>> dataListener", dl)
		dl.DataChanged()
	}
	return res
}

func (o *certListS) First() Cert {
	for _, obj := range o.M {
		return out.CatchError(obj, nil)
	}

	res := &certS{}
	res.InfoAddTrace(out.NotFound, "", 0)
	return res
}

func (o *certListS) GetByID(id string) Cert {
	res, exist := o.M[id]
	if !exist {
		res.InfoAddTrace(out.NotFound, "", 0)
		return res
	}
	return out.CatchError(res, nil)
}

func (o *certListS) Iter() []Cert {

	if o.NotValid() {
		return nil
	}

	res := []Cert{}
	for _, id := range o.IDs {
		res = append(res, out.CatchError(o.M[id], nil))
	}
	return res
}

// ---

func CertGetByID(key string) Cert {

	res := &certS{}
	if key == "" {
		res.InfoAddTrace(out.NotFound, "", 0)
		return res
	}

	dbLock.Lock()
	defer dbLock.Unlock()

	out.CatchError(res, dbConnection.Where("ID = ?", key).First(res).Error)

	if res.NotValid() && res.InfoLastTrace().Message == "record not found" {
		res.Result = out.NotFound
	}

	return res
}

//---

func CertCreate(
	DomainName string,
	ExpirationTime int64,
	Key string,
	Organization Organization,
	Pem string,
) Cert {

	// TODO: Input data validation

	now := time.Now()
	obj := &certS{
		IDC:             lwhelper.ID(),
		CreatedC:        now.Unix(),
		UpdatedC:        now.Unix(),
		DomainNameC:     DomainName,
		ExpirationTimeC: ExpirationTime,
		KeyC:            Key,
		OrganizationC:   Organization.ID(),
		PemC:            Pem,
	}

	// Saving data to the database
	dbLock.Lock()
	defer dbLock.Unlock()

	return out.CatchError(obj, dbConnection.Create(obj).Error)
}

//---
