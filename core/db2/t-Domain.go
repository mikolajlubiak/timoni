package db2

// This file is automatically generated, manual editing is not recommended.

import (
	"encoding/json"
	"fmt"
	"time"

	"fyne.io/fyne/v2/data/binding"
	"github.com/lukx33/lwhelper"
	"github.com/lukx33/lwhelper/out"
	"gorm.io/gorm"
)

var tmpDomain = lwhelper.ID()

type Domain interface {
	NotValid() bool
	InfoAddTrace(result out.ResultT, msg string, skipFrames int)
	InfoAddCause(parent out.Info) out.Info
	InfoAddVar(name string, value any) out.Info
	InfoResult() out.ResultT
	InfoTraces() []out.TraceS
	InfoLastTrace() out.TraceS
	InfoJSON() []byte
	InfoPrint()

	ID() string
	Created() int64
	Updated() int64

	Cert() Cert
	SetCert(value Cert) out.Info
	CertProvider() CertProvider
	SetCertProvider(value CertProvider) out.Info
	CertRenewBeforeDays() int64
	SetCertRenewBeforeDays(value int64) out.Info
	CertRenewError() string
	SetCertRenewError(value string) out.Info
	DNSProvider() DNSProvider
	SetDNSProvider(value DNSProvider) out.Info
	Enabled() bool
	SetEnabled(value bool) out.Info
	HTTPS() bool
	SetHTTPS(value bool) out.Info
	IP() string
	SetIP(value string) out.Info
	Name() string
	SetName(value string) out.Info
	Organization() Organization
	SetOrganization(value Organization) out.Info
	Port() int64
	SetPort(value int64) out.Info
	TLD() string
	SetTLD(value string) out.Info
	Delete() out.Info
	URL(path string) string
}
type domainS struct {
	out.DontUseMeInfoS `gorm:"-"`

	IDC      string `gorm:"column:ID;primaryKey"`
	CreatedC int64  `gorm:"column:Created;autoCreateTime"`
	UpdatedC int64  `gorm:"column:Updated;autoUpdateTime"`

	CertC                string `gorm:"column:Cert"`
	CertProviderC        string `gorm:"column:CertProvider"`
	CertRenewBeforeDaysC int64  `gorm:"column:CertRenewBeforeDays"`
	CertRenewErrorC      string `gorm:"column:CertRenewError"`
	DNSProviderC         string `gorm:"column:DNSProvider"`
	EnabledC             bool   `gorm:"column:Enabled"`
	HTTPSC               bool   `gorm:"column:HTTPS"`
	IPC                  string `gorm:"column:IP"`
	NameC                string `gorm:"column:Name"`
	OrganizationC        string `gorm:"column:Organization"`
	PortC                int64  `gorm:"column:Port"`
	TLDC                 string `gorm:"column:TLD"`
}

func (domainS) TableName() string {
	return "Domain"
}

// ---

func (o *domainS) AfterFind(tx *gorm.DB) error {
	return nil
}

// ---

func (o *domainS) InfoJSON() []byte {
	buf, _ := json.MarshalIndent(o, "", "  ")
	return buf
}

func (o *domainS) InfoPrint() {
	fmt.Println(string(o.InfoJSON()))
}

func (o *domainS) AddListener(l binding.DataListener) {
	fmt.Println("Domain AddListener")
}

func (o *domainS) RemoveListener(l binding.DataListener) {
	fmt.Println("Domain RemoveListener")
}

func (o *domainS) Delete() out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	dbLock.Lock()
	defer dbLock.Unlock()

	err := dbConnection.Where("ID = ?", o.IDC).Delete(&domainS{}).Error
	if err != nil {
		return out.New(err)
	}

	return out.NewSuccess()
}

func domainCreateOrUpdate(srcB []byte) {

	src := &domainS{}
	json.Unmarshal(srcB, src)
	id := src.IDC
	// src.InfoPrint()

	if id == "" {
		panic("cos tu jest nie tak")
	}

	srcMap := map[string]any{}
	json.Unmarshal(src.InfoJSON(), &srcMap)
	delete(srcMap, "trace")
	delete(srcMap, "result")
	delete(srcMap, "vars")
	delete(srcMap, "IDC")
	// out.PrintJSON(srcMap)

	dbLock.Lock()
	defer dbLock.Unlock()

	var exists bool
	if out.New(dbConnection.Model(&domainS{}).Select("count(*) > 0").
		Where("id = ?", id).Find(&exists).Error).NotValid() {
		return
	}
	if !exists {
		// new item, creating
		// fmt.Println("new item")
		out.New(dbConnection.Create(src).Error)
		return
	}

	// looking for changes
	// fmt.Println("changes")
	out.New(dbConnection.Model(&domainS{}).Where("ID = ?", id).Updates(srcMap).Error)
}

// ---
// ID

func (o *domainS) ID() string {
	if o == nil {
		return ""
	}
	return o.IDC
}

// ---
// Created

func (o *domainS) Created() int64 {
	if o == nil {
		return 0
	}
	return o.CreatedC
}

// ---
// Updated

func (o *domainS) Updated() int64 {
	if o == nil {
		return 0
	}
	return o.UpdatedC
}

// ---
// Cert

func (o *domainS) Cert() Cert {
	if o == nil {
		return nil
	}
	return CertGetByID(o.CertC)
}

func (o *domainS) SetCert(value Cert) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	// TODO: if current value == new value, then there is no point in changing anything

	oldValue := o.CertC
	o.CertC = value.ID()

	dbLock.Lock()
	defer dbLock.Unlock()

	err := dbConnection.Model(&domainS{}).Where("ID = ?", o.IDC).Update("Cert", value.ID()).Error
	if err != nil {
		o.CertC = oldValue
		return out.New(err)
	}

	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// CertProvider

func (o *domainS) CertProvider() CertProvider {
	if o == nil {
		return nil
	}
	return CertProviderGetByID(o.CertProviderC)
}

func (o *domainS) SetCertProvider(value CertProvider) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	// TODO: if current value == new value, then there is no point in changing anything

	oldValue := o.CertProviderC
	o.CertProviderC = value.ID()

	dbLock.Lock()
	defer dbLock.Unlock()

	err := dbConnection.Model(&domainS{}).Where("ID = ?", o.IDC).Update("CertProvider", value.ID()).Error
	if err != nil {
		o.CertProviderC = oldValue
		return out.New(err)
	}

	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// CertRenewBeforeDays

func (o *domainS) CertRenewBeforeDays() int64 {
	if o == nil {
		return 0
	}
	return o.CertRenewBeforeDaysC
}

func (o *domainS) SetCertRenewBeforeDays(value int64) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	// TODO: if current value == new value, then there is no point in changing anything

	oldValue := o.CertRenewBeforeDaysC
	o.CertRenewBeforeDaysC = value

	dbLock.Lock()
	defer dbLock.Unlock()

	err := dbConnection.Model(&domainS{}).Where("ID = ?", o.IDC).Update("CertRenewBeforeDays", value).Error
	if err != nil {
		o.CertRenewBeforeDaysC = oldValue
		return out.New(err)
	}

	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// CertRenewError

func (o *domainS) CertRenewError() string {
	if o == nil {
		return ""
	}
	return o.CertRenewErrorC
}

func (o *domainS) SetCertRenewError(value string) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	// TODO: if current value == new value, then there is no point in changing anything

	oldValue := o.CertRenewErrorC
	o.CertRenewErrorC = value

	dbLock.Lock()
	defer dbLock.Unlock()

	err := dbConnection.Model(&domainS{}).Where("ID = ?", o.IDC).Update("CertRenewError", value).Error
	if err != nil {
		o.CertRenewErrorC = oldValue
		return out.New(err)
	}

	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// DNSProvider

func (o *domainS) DNSProvider() DNSProvider {
	if o == nil {
		return nil
	}
	return DNSProviderGetByID(o.DNSProviderC)
}

func (o *domainS) SetDNSProvider(value DNSProvider) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	// TODO: if current value == new value, then there is no point in changing anything

	oldValue := o.DNSProviderC
	o.DNSProviderC = value.ID()

	dbLock.Lock()
	defer dbLock.Unlock()

	err := dbConnection.Model(&domainS{}).Where("ID = ?", o.IDC).Update("DNSProvider", value.ID()).Error
	if err != nil {
		o.DNSProviderC = oldValue
		return out.New(err)
	}

	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// Enabled

func (o *domainS) Enabled() bool {
	if o == nil {
		return false
	}
	return o.EnabledC
}

func (o *domainS) SetEnabled(value bool) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	// TODO: if current value == new value, then there is no point in changing anything

	oldValue := o.EnabledC
	o.EnabledC = value

	dbLock.Lock()
	defer dbLock.Unlock()

	err := dbConnection.Model(&domainS{}).Where("ID = ?", o.IDC).Update("Enabled", value).Error
	if err != nil {
		o.EnabledC = oldValue
		return out.New(err)
	}

	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// HTTPS

func (o *domainS) HTTPS() bool {
	if o == nil {
		return false
	}
	return o.HTTPSC
}

func (o *domainS) SetHTTPS(value bool) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	// TODO: if current value == new value, then there is no point in changing anything

	oldValue := o.HTTPSC
	o.HTTPSC = value

	dbLock.Lock()
	defer dbLock.Unlock()

	err := dbConnection.Model(&domainS{}).Where("ID = ?", o.IDC).Update("HTTPS", value).Error
	if err != nil {
		o.HTTPSC = oldValue
		return out.New(err)
	}

	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// IP

func (o *domainS) IP() string {
	if o == nil {
		return ""
	}
	return o.IPC
}

func (o *domainS) SetIP(value string) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	// TODO: if current value == new value, then there is no point in changing anything

	oldValue := o.IPC
	o.IPC = value

	dbLock.Lock()
	defer dbLock.Unlock()

	err := dbConnection.Model(&domainS{}).Where("ID = ?", o.IDC).Update("IP", value).Error
	if err != nil {
		o.IPC = oldValue
		return out.New(err)
	}

	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// Name

func (o *domainS) Name() string {
	if o == nil {
		return ""
	}
	return o.NameC
}

func (o *domainS) SetName(value string) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	// TODO: if current value == new value, then there is no point in changing anything

	oldValue := o.NameC
	o.NameC = value

	dbLock.Lock()
	defer dbLock.Unlock()

	err := dbConnection.Model(&domainS{}).Where("ID = ?", o.IDC).Update("Name", value).Error
	if err != nil {
		o.NameC = oldValue
		return out.New(err)
	}

	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// Organization

func (o *domainS) Organization() Organization {
	if o == nil {
		return nil
	}
	return OrganizationGetByID(o.OrganizationC)
}

func (o *domainS) SetOrganization(value Organization) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	// TODO: if current value == new value, then there is no point in changing anything

	oldValue := o.OrganizationC
	o.OrganizationC = value.ID()

	dbLock.Lock()
	defer dbLock.Unlock()

	err := dbConnection.Model(&domainS{}).Where("ID = ?", o.IDC).Update("Organization", value.ID()).Error
	if err != nil {
		o.OrganizationC = oldValue
		return out.New(err)
	}

	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// Port

func (o *domainS) Port() int64 {
	if o == nil {
		return 0
	}
	return o.PortC
}

func (o *domainS) SetPort(value int64) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	// TODO: if current value == new value, then there is no point in changing anything

	oldValue := o.PortC
	o.PortC = value

	dbLock.Lock()
	defer dbLock.Unlock()

	err := dbConnection.Model(&domainS{}).Where("ID = ?", o.IDC).Update("Port", value).Error
	if err != nil {
		o.PortC = oldValue
		return out.New(err)
	}

	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// TLD

func (o *domainS) TLD() string {
	if o == nil {
		return ""
	}
	return o.TLDC
}

func (o *domainS) SetTLD(value string) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	// TODO: if current value == new value, then there is no point in changing anything

	oldValue := o.TLDC
	o.TLDC = value

	dbLock.Lock()
	defer dbLock.Unlock()

	err := dbConnection.Model(&domainS{}).Where("ID = ?", o.IDC).Update("TLD", value).Error
	if err != nil {
		o.TLDC = oldValue
		return out.New(err)
	}

	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

func (o *domainS) URL(path string) string {

	scheme := "https"
	if o.CertC == "" {
		scheme = "http"
	}

	return fmt.Sprintf("%s://%s:%d%s", scheme, o.NameC, o.PortC, path)
}

// ----------------------------------------------------- table list:

type domainList interface {
	NotValid() bool
	InfoAddTrace(result out.ResultT, msg string, skipFrames int)
	InfoAddCause(parent out.Info) out.Info
	InfoAddVar(name string, value any) out.Info
	InfoResult() out.ResultT
	InfoTraces() []out.TraceS
	InfoLastTrace() out.TraceS
	InfoJSON() []byte
	InfoPrint()

	Length() int
	First() Domain
	GetByID(id string) Domain
	Iter() []Domain
	Refresh() out.Info
	SetWhere(where string) out.Info
	SetOrder(order string) out.Info
	SetOffset(offset int) out.Info
	SetLimit(limit int) out.Info

	AddListener(dl binding.DataListener)
	RemoveListener(dl binding.DataListener)
	GetItem(index int) (binding.DataItem, error)
}

type domainListS struct {
	out.DontUseMeInfoS

	query        req_listQueryS
	M            map[string]*domainS
	IDs          []string
	IDtoIdx      map[string]int
	dataListener map[binding.DataListener]bool
}

//---

func (o *domainListS) InfoJSON() []byte {
	buf, _ := json.MarshalIndent(o, "", "  ")
	return buf
}

func (o *domainListS) InfoPrint() {
	fmt.Println(string(o.InfoJSON()))
}

func (o *domainListS) AddListener(dl binding.DataListener) {
	// fmt.Println("DomainList AddListener")
	if o.dataListener == nil {
		o.dataListener = map[binding.DataListener]bool{}
	}
	o.dataListener[dl] = true
}

func (o *domainListS) RemoveListener(dl binding.DataListener) {
	// fmt.Println("DomainList RemoveListener")
	delete(o.dataListener, dl)
}

func (o *domainListS) GetItem(index int) (binding.DataItem, error) {
	// fmt.Println("DomainList GetItem")
	return o.M[o.IDs[index]], nil
}

func (o *domainListS) Length() int {
	// fmt.Println("DomainList Length")
	return len(o.IDs)
}

func (o *domainListS) SetWhere(where string) out.Info {
	o.query = req_listQueryS{
		Where: where,
	}
	return o.Refresh()
}

func (o *domainListS) SetOrder(order string) out.Info {
	o.query = req_listQueryS{
		Order: order,
	}
	return o.Refresh()
}

func (o *domainListS) SetOffset(offset int) out.Info {
	o.query = req_listQueryS{
		Offset: offset,
	}
	return o.Refresh()
}

func (o *domainListS) SetLimit(limit int) out.Info {
	o.query = req_listQueryS{
		Limit: limit,
	}
	return o.Refresh()
}

//---

func DomainList(where, order string, offset, limit int) domainList {

	response := &domainListS{
		query: req_listQueryS{
			Where:  where,
			Order:  order,
			Offset: offset,
			Limit:  limit,
		},
	}

	if where == "nil" {
		return response
	}

	response.Refresh()
	return response
}

func (o *domainListS) Refresh() out.Info {

	if o.query.Where == "nil" {
		return o
	}

	res := &domainListS{
		query:        o.query,
		IDs:          []string{},
		IDtoIdx:      map[string]int{},
		M:            map[string]*domainS{},
		dataListener: o.dataListener,
	}

	dbLock.Lock()
	defer dbLock.Unlock()

	st := dbConnection.Model(&domainS{})
	if o.query.Where != "" {
		st.Where(o.query.Where)
	}
	if o.query.Order == "" {
		o.query.Order = "Created"
	}
	if o.query.Limit == 0 {
		o.query.Limit = 30
	}

	responseList := []*domainS{}
	if out.CatchError(res,
		st.Order(o.query.Order).Offset(o.query.Offset).Limit(o.query.Limit).Find(&responseList).Error,
	).NotValid() {
		return res
	}
	// out.PrintJSON(responseList)

	for idx, entry := range responseList {
		res.IDs = append(res.IDs, entry.IDC)
		res.IDtoIdx[entry.IDC] = idx
		res.M[entry.IDC] = entry
	}

	out.CatchError(res, nil)
	*o = *res

	for dl := range o.dataListener {
		// fmt.Println(">>>>>>>>>>>>>>>>>> dataListener", dl)
		dl.DataChanged()
	}
	return res
}

func (o *domainListS) First() Domain {
	for _, obj := range o.M {
		return out.CatchError(obj, nil)
	}

	res := &domainS{}
	res.InfoAddTrace(out.NotFound, "", 0)
	return res
}

func (o *domainListS) GetByID(id string) Domain {
	res, exist := o.M[id]
	if !exist {
		res.InfoAddTrace(out.NotFound, "", 0)
		return res
	}
	return out.CatchError(res, nil)
}

func (o *domainListS) Iter() []Domain {

	if o.NotValid() {
		return nil
	}

	res := []Domain{}
	for _, id := range o.IDs {
		res = append(res, out.CatchError(o.M[id], nil))
	}
	return res
}

// ---

func DomainGetByID(key string) Domain {

	res := &domainS{}
	if key == "" {
		res.InfoAddTrace(out.NotFound, "", 0)
		return res
	}

	dbLock.Lock()
	defer dbLock.Unlock()

	out.CatchError(res, dbConnection.Where("ID = ?", key).First(res).Error)

	if res.NotValid() && res.InfoLastTrace().Message == "record not found" {
		res.Result = out.NotFound
	}

	return res
}

//---

func DomainCreate(
	Cert Cert,
	CertProvider CertProvider,
	DNSProvider DNSProvider,
	IP string,
	Name string,
	Organization Organization,
	TLD string,
) Domain {

	// TODO: Input data validation

	now := time.Now()
	obj := &domainS{
		IDC:           lwhelper.ID(),
		CreatedC:      now.Unix(),
		UpdatedC:      now.Unix(),
		CertC:         Cert.ID(),
		CertProviderC: CertProvider.ID(),
		DNSProviderC:  DNSProvider.ID(),
		IPC:           IP,
		NameC:         Name,
		OrganizationC: Organization.ID(),
		TLDC:          TLD,
	}

	obj.CertRenewBeforeDaysC = 8
	obj.EnabledC = true
	obj.HTTPSC = true
	obj.PortC = 443

	// Saving data to the database
	dbLock.Lock()
	defer dbLock.Unlock()

	return out.CatchError(obj, dbConnection.Create(obj).Error)
}

//---
