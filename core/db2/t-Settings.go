package db2

// This file is automatically generated, manual editing is not recommended.

import (
	"encoding/json"
	"fmt"
	"time"

	"fyne.io/fyne/v2/data/binding"
	"github.com/lukx33/lwhelper"
	"github.com/lukx33/lwhelper/out"
	"gorm.io/gorm"
)

var tmpSettings = lwhelper.ID()

type Settings interface {
	NotValid() bool
	InfoAddTrace(result out.ResultT, msg string, skipFrames int)
	InfoAddCause(parent out.Info) out.Info
	InfoAddVar(name string, value any) out.Info
	InfoResult() out.ResultT
	InfoTraces() []out.TraceS
	InfoLastTrace() out.TraceS
	InfoJSON() []byte
	InfoPrint()

	ID() string
	Created() int64
	Updated() int64

	APIInternalIP() string
	SetAPIInternalIP(value string) out.Info
	DatabaseSizeGB() int64
	SetDatabaseSizeGB(value int64) out.Info
	ForceResourceLimits() bool
	SetForceResourceLimits(value bool) out.Info
	GitProvider() GitProvider
	SetGitProvider(value GitProvider) out.Info
	GitServerLocalHide() bool
	SetGitServerLocalHide(value bool) out.Info
	ImageBuilder() ImageBuilder
	SetImageBuilder(value ImageBuilder) out.Info
	Ingress() Ingress
	SetIngress(value Ingress) out.Info
	Kube() Kube
	SetKube(value Kube) out.Info
	LastIP() string
	SetLastIP(value string) out.Info
	LastSync() int64
	SetLastSync(value int64) out.Info
	LogoSvgBase64() string
	SetLogoSvgBase64(value string) out.Info
	Longhorn() bool
	SetLonghorn(value bool) out.Info
	Metrics() Metrics
	SetMetrics(value Metrics) out.Info
	Name() string
	SetName(value string) out.Info
	OrganizationID() string
	SetOrganizationID(value string) out.Info
	ReleaseGitTag() string
	SetReleaseGitTag(value string) out.Info
	Version() int64
	SetVersion(value int64) out.Info
	VirtualIP() string
	SetVirtualIP(value string) out.Info
	VirtualInterface() string
	SetVirtualInterface(value string) out.Info
	WebUIDomain() Domain
	SetWebUIDomain(value Domain) out.Info
	Delete() out.Info
}
type settingsS struct {
	out.DontUseMeInfoS `gorm:"-"`

	IDC      string `gorm:"column:ID;primaryKey"`
	CreatedC int64  `gorm:"column:Created;autoCreateTime"`
	UpdatedC int64  `gorm:"column:Updated;autoUpdateTime"`

	APIInternalIPC       string `gorm:"column:APIInternalIP"`
	DatabaseSizeGBC      int64  `gorm:"column:DatabaseSizeGB"`
	ForceResourceLimitsC bool   `gorm:"column:ForceResourceLimits"`
	GitProviderC         string `gorm:"column:GitProvider"`
	GitServerLocalHideC  bool   `gorm:"column:GitServerLocalHide"`
	ImageBuilderC        string `gorm:"column:ImageBuilder"`
	IngressC             string `gorm:"column:Ingress"`
	KubeC                string `gorm:"column:Kube;uniqueIndex"`
	LastIPC              string `gorm:"column:LastIP"`
	LastSyncC            int64  `gorm:"column:LastSync"`
	LogoSvgBase64C       string `gorm:"column:LogoSvgBase64"`
	LonghornC            bool   `gorm:"column:Longhorn"`
	MetricsC             string `gorm:"column:Metrics"`
	NameC                string `gorm:"column:Name"`
	OrganizationIDC      string `gorm:"column:OrganizationID"`
	ReleaseGitTagC       string `gorm:"column:ReleaseGitTag"`
	VersionC             int64  `gorm:"column:Version"`
	VirtualIPC           string `gorm:"column:VirtualIP"`
	VirtualInterfaceC    string `gorm:"column:VirtualInterface"`
	WebUIDomainC         string `gorm:"column:WebUIDomain;uniqueIndex"`
}

func (settingsS) TableName() string {
	return "Settings"
}

// ---

func (o *settingsS) AfterFind(tx *gorm.DB) error {
	return nil
}

// ---

func (o *settingsS) InfoJSON() []byte {
	buf, _ := json.MarshalIndent(o, "", "  ")
	return buf
}

func (o *settingsS) InfoPrint() {
	fmt.Println(string(o.InfoJSON()))
}

func (o *settingsS) AddListener(l binding.DataListener) {
	fmt.Println("Settings AddListener")
}

func (o *settingsS) RemoveListener(l binding.DataListener) {
	fmt.Println("Settings RemoveListener")
}

func (o *settingsS) Delete() out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	dbLock.Lock()
	defer dbLock.Unlock()

	err := dbConnection.Where("ID = ?", o.IDC).Delete(&settingsS{}).Error
	if err != nil {
		return out.New(err)
	}

	return out.NewSuccess()
}

func settingsCreateOrUpdate(srcB []byte) {

	src := &settingsS{}
	json.Unmarshal(srcB, src)
	id := src.IDC
	// src.InfoPrint()

	if id == "" {
		panic("cos tu jest nie tak")
	}

	srcMap := map[string]any{}
	json.Unmarshal(src.InfoJSON(), &srcMap)
	delete(srcMap, "trace")
	delete(srcMap, "result")
	delete(srcMap, "vars")
	delete(srcMap, "IDC")
	// out.PrintJSON(srcMap)

	dbLock.Lock()
	defer dbLock.Unlock()

	var exists bool
	if out.New(dbConnection.Model(&settingsS{}).Select("count(*) > 0").
		Where("id = ?", id).Find(&exists).Error).NotValid() {
		return
	}
	if !exists {
		// new item, creating
		// fmt.Println("new item")
		out.New(dbConnection.Create(src).Error)
		return
	}

	// looking for changes
	// fmt.Println("changes")
	out.New(dbConnection.Model(&settingsS{}).Where("ID = ?", id).Updates(srcMap).Error)
}

// ---
// ID

func (o *settingsS) ID() string {
	if o == nil {
		return ""
	}
	return o.IDC
}

// ---
// Created

func (o *settingsS) Created() int64 {
	if o == nil {
		return 0
	}
	return o.CreatedC
}

// ---
// Updated

func (o *settingsS) Updated() int64 {
	if o == nil {
		return 0
	}
	return o.UpdatedC
}

// ---
// APIInternalIP

func (o *settingsS) APIInternalIP() string {
	if o == nil {
		return ""
	}
	return o.APIInternalIPC
}

func (o *settingsS) SetAPIInternalIP(value string) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	// TODO: if current value == new value, then there is no point in changing anything

	oldValue := o.APIInternalIPC
	o.APIInternalIPC = value

	dbLock.Lock()
	defer dbLock.Unlock()

	err := dbConnection.Model(&settingsS{}).Where("ID = ?", o.IDC).Update("APIInternalIP", value).Error
	if err != nil {
		o.APIInternalIPC = oldValue
		return out.New(err)
	}

	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// DatabaseSizeGB

func (o *settingsS) DatabaseSizeGB() int64 {
	if o == nil {
		return 0
	}
	return o.DatabaseSizeGBC
}

func (o *settingsS) SetDatabaseSizeGB(value int64) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	// TODO: if current value == new value, then there is no point in changing anything

	oldValue := o.DatabaseSizeGBC
	o.DatabaseSizeGBC = value

	dbLock.Lock()
	defer dbLock.Unlock()

	err := dbConnection.Model(&settingsS{}).Where("ID = ?", o.IDC).Update("DatabaseSizeGB", value).Error
	if err != nil {
		o.DatabaseSizeGBC = oldValue
		return out.New(err)
	}

	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// ForceResourceLimits

func (o *settingsS) ForceResourceLimits() bool {
	if o == nil {
		return false
	}
	return o.ForceResourceLimitsC
}

func (o *settingsS) SetForceResourceLimits(value bool) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	// TODO: if current value == new value, then there is no point in changing anything

	oldValue := o.ForceResourceLimitsC
	o.ForceResourceLimitsC = value

	dbLock.Lock()
	defer dbLock.Unlock()

	err := dbConnection.Model(&settingsS{}).Where("ID = ?", o.IDC).Update("ForceResourceLimits", value).Error
	if err != nil {
		o.ForceResourceLimitsC = oldValue
		return out.New(err)
	}

	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// GitProvider

func (o *settingsS) GitProvider() GitProvider {
	if o == nil {
		return nil
	}
	return GitProviderGetByID(o.GitProviderC)
}

func (o *settingsS) SetGitProvider(value GitProvider) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	// TODO: if current value == new value, then there is no point in changing anything

	oldValue := o.GitProviderC
	o.GitProviderC = value.ID()

	dbLock.Lock()
	defer dbLock.Unlock()

	err := dbConnection.Model(&settingsS{}).Where("ID = ?", o.IDC).Update("GitProvider", value.ID()).Error
	if err != nil {
		o.GitProviderC = oldValue
		return out.New(err)
	}

	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// GitServerLocalHide

func (o *settingsS) GitServerLocalHide() bool {
	if o == nil {
		return false
	}
	return o.GitServerLocalHideC
}

func (o *settingsS) SetGitServerLocalHide(value bool) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	// TODO: if current value == new value, then there is no point in changing anything

	oldValue := o.GitServerLocalHideC
	o.GitServerLocalHideC = value

	dbLock.Lock()
	defer dbLock.Unlock()

	err := dbConnection.Model(&settingsS{}).Where("ID = ?", o.IDC).Update("GitServerLocalHide", value).Error
	if err != nil {
		o.GitServerLocalHideC = oldValue
		return out.New(err)
	}

	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// ImageBuilder

func (o *settingsS) ImageBuilder() ImageBuilder {
	if o == nil {
		return nil
	}
	return ImageBuilderGetByID(o.ImageBuilderC)
}

func (o *settingsS) SetImageBuilder(value ImageBuilder) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	// TODO: if current value == new value, then there is no point in changing anything

	oldValue := o.ImageBuilderC
	o.ImageBuilderC = value.ID()

	dbLock.Lock()
	defer dbLock.Unlock()

	err := dbConnection.Model(&settingsS{}).Where("ID = ?", o.IDC).Update("ImageBuilder", value.ID()).Error
	if err != nil {
		o.ImageBuilderC = oldValue
		return out.New(err)
	}

	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// Ingress

func (o *settingsS) Ingress() Ingress {
	if o == nil {
		return nil
	}
	return IngressGetByID(o.IngressC)
}

func (o *settingsS) SetIngress(value Ingress) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	// TODO: if current value == new value, then there is no point in changing anything

	oldValue := o.IngressC
	o.IngressC = value.ID()

	dbLock.Lock()
	defer dbLock.Unlock()

	err := dbConnection.Model(&settingsS{}).Where("ID = ?", o.IDC).Update("Ingress", value.ID()).Error
	if err != nil {
		o.IngressC = oldValue
		return out.New(err)
	}

	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// Kube

func (o *settingsS) Kube() Kube {
	if o == nil {
		return nil
	}
	return KubeGetByID(o.KubeC)
}

func (o *settingsS) SetKube(value Kube) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	// TODO: if current value == new value, then there is no point in changing anything

	oldValue := o.KubeC
	o.KubeC = value.ID()

	dbLock.Lock()
	defer dbLock.Unlock()

	err := dbConnection.Model(&settingsS{}).Where("ID = ?", o.IDC).Update("Kube", value.ID()).Error
	if err != nil {
		o.KubeC = oldValue
		return out.New(err)
	}

	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// LastIP

func (o *settingsS) LastIP() string {
	if o == nil {
		return ""
	}
	return o.LastIPC
}

func (o *settingsS) SetLastIP(value string) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	// TODO: if current value == new value, then there is no point in changing anything

	oldValue := o.LastIPC
	o.LastIPC = value

	dbLock.Lock()
	defer dbLock.Unlock()

	err := dbConnection.Model(&settingsS{}).Where("ID = ?", o.IDC).Update("LastIP", value).Error
	if err != nil {
		o.LastIPC = oldValue
		return out.New(err)
	}

	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// LastSync

func (o *settingsS) LastSync() int64 {
	if o == nil {
		return 0
	}
	return o.LastSyncC
}

func (o *settingsS) SetLastSync(value int64) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	// TODO: if current value == new value, then there is no point in changing anything

	oldValue := o.LastSyncC
	o.LastSyncC = value

	dbLock.Lock()
	defer dbLock.Unlock()

	err := dbConnection.Model(&settingsS{}).Where("ID = ?", o.IDC).Update("LastSync", value).Error
	if err != nil {
		o.LastSyncC = oldValue
		return out.New(err)
	}

	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// LogoSvgBase64

func (o *settingsS) LogoSvgBase64() string {
	if o == nil {
		return ""
	}
	return o.LogoSvgBase64C
}

func (o *settingsS) SetLogoSvgBase64(value string) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	// TODO: if current value == new value, then there is no point in changing anything

	oldValue := o.LogoSvgBase64C
	o.LogoSvgBase64C = value

	dbLock.Lock()
	defer dbLock.Unlock()

	err := dbConnection.Model(&settingsS{}).Where("ID = ?", o.IDC).Update("LogoSvgBase64", value).Error
	if err != nil {
		o.LogoSvgBase64C = oldValue
		return out.New(err)
	}

	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// Longhorn

func (o *settingsS) Longhorn() bool {
	if o == nil {
		return false
	}
	return o.LonghornC
}

func (o *settingsS) SetLonghorn(value bool) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	// TODO: if current value == new value, then there is no point in changing anything

	oldValue := o.LonghornC
	o.LonghornC = value

	dbLock.Lock()
	defer dbLock.Unlock()

	err := dbConnection.Model(&settingsS{}).Where("ID = ?", o.IDC).Update("Longhorn", value).Error
	if err != nil {
		o.LonghornC = oldValue
		return out.New(err)
	}

	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// Metrics

func (o *settingsS) Metrics() Metrics {
	if o == nil {
		return nil
	}
	return MetricsGetByID(o.MetricsC)
}

func (o *settingsS) SetMetrics(value Metrics) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	// TODO: if current value == new value, then there is no point in changing anything

	oldValue := o.MetricsC
	o.MetricsC = value.ID()

	dbLock.Lock()
	defer dbLock.Unlock()

	err := dbConnection.Model(&settingsS{}).Where("ID = ?", o.IDC).Update("Metrics", value.ID()).Error
	if err != nil {
		o.MetricsC = oldValue
		return out.New(err)
	}

	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// Name

func (o *settingsS) Name() string {
	if o == nil {
		return ""
	}
	return o.NameC
}

func (o *settingsS) SetName(value string) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	// TODO: if current value == new value, then there is no point in changing anything

	oldValue := o.NameC
	o.NameC = value

	dbLock.Lock()
	defer dbLock.Unlock()

	err := dbConnection.Model(&settingsS{}).Where("ID = ?", o.IDC).Update("Name", value).Error
	if err != nil {
		o.NameC = oldValue
		return out.New(err)
	}

	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// OrganizationID

func (o *settingsS) OrganizationID() string {
	if o == nil {
		return ""
	}
	return o.OrganizationIDC
}

func (o *settingsS) SetOrganizationID(value string) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	// TODO: if current value == new value, then there is no point in changing anything

	oldValue := o.OrganizationIDC
	o.OrganizationIDC = value

	dbLock.Lock()
	defer dbLock.Unlock()

	err := dbConnection.Model(&settingsS{}).Where("ID = ?", o.IDC).Update("OrganizationID", value).Error
	if err != nil {
		o.OrganizationIDC = oldValue
		return out.New(err)
	}

	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// ReleaseGitTag

func (o *settingsS) ReleaseGitTag() string {
	if o == nil {
		return ""
	}
	return o.ReleaseGitTagC
}

func (o *settingsS) SetReleaseGitTag(value string) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	// TODO: if current value == new value, then there is no point in changing anything

	oldValue := o.ReleaseGitTagC
	o.ReleaseGitTagC = value

	dbLock.Lock()
	defer dbLock.Unlock()

	err := dbConnection.Model(&settingsS{}).Where("ID = ?", o.IDC).Update("ReleaseGitTag", value).Error
	if err != nil {
		o.ReleaseGitTagC = oldValue
		return out.New(err)
	}

	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// Version

func (o *settingsS) Version() int64 {
	if o == nil {
		return 0
	}
	return o.VersionC
}

func (o *settingsS) SetVersion(value int64) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	// TODO: if current value == new value, then there is no point in changing anything

	oldValue := o.VersionC
	o.VersionC = value

	dbLock.Lock()
	defer dbLock.Unlock()

	err := dbConnection.Model(&settingsS{}).Where("ID = ?", o.IDC).Update("Version", value).Error
	if err != nil {
		o.VersionC = oldValue
		return out.New(err)
	}

	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// VirtualIP

func (o *settingsS) VirtualIP() string {
	if o == nil {
		return ""
	}
	return o.VirtualIPC
}

func (o *settingsS) SetVirtualIP(value string) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	// TODO: if current value == new value, then there is no point in changing anything

	oldValue := o.VirtualIPC
	o.VirtualIPC = value

	dbLock.Lock()
	defer dbLock.Unlock()

	err := dbConnection.Model(&settingsS{}).Where("ID = ?", o.IDC).Update("VirtualIP", value).Error
	if err != nil {
		o.VirtualIPC = oldValue
		return out.New(err)
	}

	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// VirtualInterface

func (o *settingsS) VirtualInterface() string {
	if o == nil {
		return ""
	}
	return o.VirtualInterfaceC
}

func (o *settingsS) SetVirtualInterface(value string) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	// TODO: if current value == new value, then there is no point in changing anything

	oldValue := o.VirtualInterfaceC
	o.VirtualInterfaceC = value

	dbLock.Lock()
	defer dbLock.Unlock()

	err := dbConnection.Model(&settingsS{}).Where("ID = ?", o.IDC).Update("VirtualInterface", value).Error
	if err != nil {
		o.VirtualInterfaceC = oldValue
		return out.New(err)
	}

	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ---
// WebUIDomain

func (o *settingsS) WebUIDomain() Domain {
	if o == nil {
		return nil
	}
	return DomainGetByID(o.WebUIDomainC)
}

func (o *settingsS) SetWebUIDomain(value Domain) out.Info {

	if o == nil {
		return out.NewErrorMsg("object is nil")
	}
	if o.NotValid() {
		return out.NewErrorMsg("object is not valid")
	}

	// TODO: validation

	// TODO: if current value == new value, then there is no point in changing anything

	oldValue := o.WebUIDomainC
	o.WebUIDomainC = value.ID()

	dbLock.Lock()
	defer dbLock.Unlock()

	err := dbConnection.Model(&settingsS{}).Where("ID = ?", o.IDC).Update("WebUIDomain", value.ID()).Error
	if err != nil {
		o.WebUIDomainC = oldValue
		return out.New(err)
	}

	o.UpdatedC = time.Now().Unix()
	return out.NewSuccess()
}

// ----------------------------------------------------- table list:

type settingsList interface {
	NotValid() bool
	InfoAddTrace(result out.ResultT, msg string, skipFrames int)
	InfoAddCause(parent out.Info) out.Info
	InfoAddVar(name string, value any) out.Info
	InfoResult() out.ResultT
	InfoTraces() []out.TraceS
	InfoLastTrace() out.TraceS
	InfoJSON() []byte
	InfoPrint()

	Length() int
	First() Settings
	GetByID(id string) Settings
	Iter() []Settings
	Refresh() out.Info
	SetWhere(where string) out.Info
	SetOrder(order string) out.Info
	SetOffset(offset int) out.Info
	SetLimit(limit int) out.Info

	AddListener(dl binding.DataListener)
	RemoveListener(dl binding.DataListener)
	GetItem(index int) (binding.DataItem, error)
}

type settingsListS struct {
	out.DontUseMeInfoS

	query        req_listQueryS
	M            map[string]*settingsS
	IDs          []string
	IDtoIdx      map[string]int
	dataListener map[binding.DataListener]bool
}

//---

func (o *settingsListS) InfoJSON() []byte {
	buf, _ := json.MarshalIndent(o, "", "  ")
	return buf
}

func (o *settingsListS) InfoPrint() {
	fmt.Println(string(o.InfoJSON()))
}

func (o *settingsListS) AddListener(dl binding.DataListener) {
	// fmt.Println("SettingsList AddListener")
	if o.dataListener == nil {
		o.dataListener = map[binding.DataListener]bool{}
	}
	o.dataListener[dl] = true
}

func (o *settingsListS) RemoveListener(dl binding.DataListener) {
	// fmt.Println("SettingsList RemoveListener")
	delete(o.dataListener, dl)
}

func (o *settingsListS) GetItem(index int) (binding.DataItem, error) {
	// fmt.Println("SettingsList GetItem")
	return o.M[o.IDs[index]], nil
}

func (o *settingsListS) Length() int {
	// fmt.Println("SettingsList Length")
	return len(o.IDs)
}

func (o *settingsListS) SetWhere(where string) out.Info {
	o.query = req_listQueryS{
		Where: where,
	}
	return o.Refresh()
}

func (o *settingsListS) SetOrder(order string) out.Info {
	o.query = req_listQueryS{
		Order: order,
	}
	return o.Refresh()
}

func (o *settingsListS) SetOffset(offset int) out.Info {
	o.query = req_listQueryS{
		Offset: offset,
	}
	return o.Refresh()
}

func (o *settingsListS) SetLimit(limit int) out.Info {
	o.query = req_listQueryS{
		Limit: limit,
	}
	return o.Refresh()
}

//---

func SettingsList(where, order string, offset, limit int) settingsList {

	response := &settingsListS{
		query: req_listQueryS{
			Where:  where,
			Order:  order,
			Offset: offset,
			Limit:  limit,
		},
	}

	if where == "nil" {
		return response
	}

	response.Refresh()
	return response
}

func (o *settingsListS) Refresh() out.Info {

	if o.query.Where == "nil" {
		return o
	}

	res := &settingsListS{
		query:        o.query,
		IDs:          []string{},
		IDtoIdx:      map[string]int{},
		M:            map[string]*settingsS{},
		dataListener: o.dataListener,
	}

	dbLock.Lock()
	defer dbLock.Unlock()

	st := dbConnection.Model(&settingsS{})
	if o.query.Where != "" {
		st.Where(o.query.Where)
	}
	if o.query.Order == "" {
		o.query.Order = "Created"
	}
	if o.query.Limit == 0 {
		o.query.Limit = 30
	}

	responseList := []*settingsS{}
	if out.CatchError(res,
		st.Order(o.query.Order).Offset(o.query.Offset).Limit(o.query.Limit).Find(&responseList).Error,
	).NotValid() {
		return res
	}
	// out.PrintJSON(responseList)

	for idx, entry := range responseList {
		res.IDs = append(res.IDs, entry.IDC)
		res.IDtoIdx[entry.IDC] = idx
		res.M[entry.IDC] = entry
	}

	out.CatchError(res, nil)
	*o = *res

	for dl := range o.dataListener {
		// fmt.Println(">>>>>>>>>>>>>>>>>> dataListener", dl)
		dl.DataChanged()
	}
	return res
}

func (o *settingsListS) First() Settings {
	for _, obj := range o.M {
		return out.CatchError(obj, nil)
	}

	res := &settingsS{}
	res.InfoAddTrace(out.NotFound, "", 0)
	return res
}

func (o *settingsListS) GetByID(id string) Settings {
	res, exist := o.M[id]
	if !exist {
		res.InfoAddTrace(out.NotFound, "", 0)
		return res
	}
	return out.CatchError(res, nil)
}

func (o *settingsListS) Iter() []Settings {

	if o.NotValid() {
		return nil
	}

	res := []Settings{}
	for _, id := range o.IDs {
		res = append(res, out.CatchError(o.M[id], nil))
	}
	return res
}

// ---

func SettingsGetByID(key string) Settings {

	res := &settingsS{}
	if key == "" {
		res.InfoAddTrace(out.NotFound, "", 0)
		return res
	}

	dbLock.Lock()
	defer dbLock.Unlock()

	out.CatchError(res, dbConnection.Where("ID = ?", key).First(res).Error)

	if res.NotValid() && res.InfoLastTrace().Message == "record not found" {
		res.Result = out.NotFound
	}

	return res
}

// ---

func SettingsGetByKube(key string) Settings {

	res := &settingsS{}
	if key == "" {
		res.InfoAddTrace(out.NotFound, "", 0)
		return res
	}

	dbLock.Lock()
	defer dbLock.Unlock()

	out.CatchError(res, dbConnection.Where("Kube = ?", key).First(res).Error)

	if res.NotValid() && res.InfoLastTrace().Message == "record not found" {
		res.Result = out.NotFound
	}

	return res
}

// ---

func SettingsGetByWebUIDomain(key string) Settings {

	res := &settingsS{}
	if key == "" {
		res.InfoAddTrace(out.NotFound, "", 0)
		return res
	}

	dbLock.Lock()
	defer dbLock.Unlock()

	out.CatchError(res, dbConnection.Where("WebUIDomain = ?", key).First(res).Error)

	if res.NotValid() && res.InfoLastTrace().Message == "record not found" {
		res.Result = out.NotFound
	}

	return res
}

//---

func SettingsCreate(
	GitProvider GitProvider,
	ImageBuilder ImageBuilder,
	Ingress Ingress,
	Kube Kube,
	LogoSvgBase64 string,
	Metrics Metrics,
	Name string,
	OrganizationID string,
	ReleaseGitTag string,
	Version int64,
	WebUIDomain Domain,
) Settings {

	// TODO: Input data validation

	now := time.Now()
	obj := &settingsS{
		IDC:             lwhelper.ID(),
		CreatedC:        now.Unix(),
		UpdatedC:        now.Unix(),
		GitProviderC:    GitProvider.ID(),
		ImageBuilderC:   ImageBuilder.ID(),
		IngressC:        Ingress.ID(),
		KubeC:           Kube.ID(),
		LogoSvgBase64C:  LogoSvgBase64,
		MetricsC:        Metrics.ID(),
		NameC:           Name,
		OrganizationIDC: OrganizationID,
		ReleaseGitTagC:  ReleaseGitTag,
		VersionC:        Version,
		WebUIDomainC:    WebUIDomain.ID(),
	}

	obj.DatabaseSizeGBC = 2
	obj.ForceResourceLimitsC = false
	obj.GitServerLocalHideC = false
	obj.LonghornC = false

	// Saving data to the database
	dbLock.Lock()
	defer dbLock.Unlock()

	return out.CatchError(obj, dbConnection.Create(obj).Error)
}

//---
